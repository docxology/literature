Systems of bounded rational agents with
information-theoretic constraints
Sebastian Gottwald1 and Daniel A. Braun1
1Institute of Neural Information Processing, Faculty of Engineering, Computer Science
and Psychology, University of Ulm.
Keywords: Bounded rationality, multi-agent systems, hierarchical structure, spe-
cialization, Free Energy principle
Abstract
Specialization and hierarchical organization are important features of efﬁcient
collaboration in economical, artiﬁcial, and biological systems. Here, we investi-
gate the hypothesis that both features can be explained by the fact that each entity
of such a system is limited in a certain way. We propose an information-theoretic
approach based on a Free Energy principle, in order to computationally analyze
systems of bounded rational agents that deal with such limitations optimally. We
ﬁnd that specialization allows to focus on fewer tasks, thus leading to a more ef-
ﬁcient execution, but in turn requires coordination in hierarchical structures of
specialized experts and coordinating units. Our results suggest that hierarchical
architectures of specialized units at lower levels that are coordinated by units at
higher levels are optimal, given that each unit’s information-processing capability
is limited and conforms to constraints on complexity costs.
1 Introduction
The question of how to combine a given set of individual entities in order to perform a
certain task efﬁciently is a long-lasting question shared by many disciplines, including
economics, neuroscience, and computer science. Even though the explicit nature of a
single individuum might differ between these ﬁelds, e.g. an employee of a company,
a neuron in a human brain, or a computer or processor as part of a cluster, they have
one important feature in common that usually prevents them from functioning isolated
by themselves: they are all limited. In fact, this was the driving idea that inspired Her-
bert A. Simons early work on decision-making within economic organizations (Simon,
1943, 1955), which earned him a Nobel prize in 1978. He suggested that a scientiﬁc
behavioral grounding of economics should be based on bounded rationality, which has
arXiv:1809.05897v1  [cs.MA]  16 Sep 2018
remained an active research topic until today (Russell and Subramanian, 1995; Lipman,
1995; Aumann, 1997; Kaelbling et al., 1998; DeCanio and Watkins, 1998; Gigerenzer
and Selten, 2001; Jones, 2003; Sims, 2003; Burns et al., 2013; Ortega and Braun, 2013;
Acerbi et al., 2014; Gershman et al., 2015). Subsequent studies in management theory
have been built upon Simons basic observation, because “if individual managers had
unlimited access to information that they could process costlessly and instantaneously,
there would be no role for organizations employing multiple managers” (Geanakoplos
and Milgrom, 1991). In neuroscience and biology, similar concepts have been used
to explore the evolution of specialization and modularity in nature (Kashtan and Alon,
2005; Wagner et al., 2007). In modern computer science, the terms parallel computing
and distributed computing denote two separate ﬁelds that share the concept of decen-
tralized computing (Radner, 1993), i.e. the combination of multiple processing units in
order to decrease the time of computationally expensive calculations.
Despite of their success, there are also shortcomings of most approaches to the or-
ganization of decision-making units based on bounded rationality: As (DeCanio and
Watkins, 1998) point out, existing agent-based methods (including their own) are not
using an overreaching optimization principle, but are tailored to the speciﬁc types of
calculations the agents are capable of, and therefore lack in generality. Moreover, it
is usually imposed as a separate assumption that there are two types of units, special-
ized operational units and coordinating non-operational units, which was expressed by
(Knight, 1921) as “workers do, and managers ﬁgure out what to do”.
Here, we use a Free Energy optimization principle in order to study systems of
bounded rational agents, extending the work in (Ortega and Braun, 2011, 2013; Ge-
newein and Braun, 2013; Genewein et al., 2015) on decision-making, hierarchical in-
formation-processing, and abstraction in intelligent systems with limited information-
processing capacity, that has precursors in the economic and game-theoretic literature
(McKelvey and Palfrey, 1995; Ochs, 1995; Mattsson and Weibull, 2002; Wolpert, 2006;
Spiegler, 2011; Howes et al., 2009; Todorov, 2009; Still, 2009; Tishby and Polani, 2011;
Kappen et al., 2012; Edward et al., 2014; Lewis et al., 2014). Note that the Free En-
ergy optimization principle of information-theoretic bounded rationality is connected
to the Free Energy principle used in variational Bayes and Active Inference (Friston
et al., 2015a,b, 2017a,b), but has a conceptually distinct interpretation and some formal
differences (see Section 6.3 for a detailed comparison).
By generalizing the ideas in (Genewein and Braun, 2013; Genewein et al., 2015) on
two-step information-processing to an arbitrary number of steps, we arrive at a general
Free Energy principle that can be used to study systems of bounded rational agents. The
advantages of our approach can be summarized as follows:
(i) There is a unifying Free Energy principle that allows for a multi-scale problem
formulation for an arbitrary amount of agents distributed among the steps of gen-
eral multi-step processes (see Sections 3.3 and 4.2).
(ii) The computational nature of the optimization principle allows to explicitly cal-
culate and compare optimal performances of different agent architectures for a
given set of objectives and resource constraints (see Section 5).
(iii) The information-theoretic description implies the existance of the two types of
2
units mentioned above, non-operational units (selector nodes) that coordinate the
activities of operational units. Depending on their individual resource constraints,
the Free Energy principle assigns each unit to a region of specialization that is part
of an optimal partitioning of the underlying decision space (see Section 4.3).
In particular, we ﬁnd that, for a wide range of objectives and resource limitations
(see Sections 5 and 5), hierarchical systems with specialized experts at lower levels and
coordinating units at higher levels generally outperform other structures.
2 Preliminaries
This section serves as an introduction to the terminology required for our framework
presented in Section 3 and 4.
Notation
We use curly letters, W, X, A, etc. to denote sets of ﬁnite cardinality, in particular the
underlying spaces of the corresponding random variables W, A, X, etc., whereas the
values of these random variables are denoted by small letters, i.e. w ∈W , a ∈A,
and x ∈X , respectively. We denote the space of probability distributions on a given
set Xby PX. Given a probability distribution p ∈PX, the expectation of a function
f : X→ R is denoted by ⟨f⟩p := ∑
xp(x)f(x). If the underlying probability measure
is clear without ambiguity we just write ⟨f⟩.
For a function gwith multiple arguments, e.g. for g: X×Y→ R,(x,y) ↦→g(x,y),
we denote the function X→R,x ↦→g(x,y) for ﬁxed y ∈Y by g(·,y) (partial applica-
tion), i.e. the dot indicates the variable of the new function. Similarly, for ﬁxed y ∈Y,
we denote a conditional probability distribution onXwith values p(x|y) by p(·|y). This
notation shows the dependencies clearly without giving up the original function names
and thus allows to write more complicated expressions in a concise form. For example,
if F is a functional deﬁned on functions of one variable, e.g. F[f] := ∑
xf(x) for all
functions f : X →R, then evaluating F on the function g in its ﬁrst variable while
keeping the second variable ﬁxed, is simply denoted by F[g(·,y)]. Here, the dot indi-
cates on which argument of gthe functional F is acting and at the same time it records
that the resulting value (which equals ∑
xg(x,y) in the case of the example) does not
depend on a particular xbut on the ﬁxed y.
2.1 Decision-making
Here, we consider (multi-task) decision-making as the process of observing a world
state w∈W, sampled from a given distributionρ∈PW, and choosing a corresponding
action a ∈A drawn from a posterior policy P(·|w) ∈PA. Assuming that the joint
distribution of W and Ais given by p(a,w) := ρ(w)P(a|w), then P is the conditional
probability distribution of A given W. Unless stated otherwise, the capital letter P
always denotes a posterior, while the small letter p denotes the joint distribution or a
marginal of the joint (i.e. a dependent variable).
3
A decision-making unit is called agent. An agent is rational, if its posterior policy
P maximizes the expected utility
⟨U⟩=
∑
w∈W
ρ(w)
∑
a∈A
P(a|w) U(a,w) (1)
for a given utility function U : W×A→ R. Note that the utility U may itself represent
an expected utility over consequences in the sense of von Neumann and Morgenstern
(1944), where W would serve as a context variable for different tasks. The posterior P
can be seen as a state-action policy that selects the best action a ∈A with respect to a
utility function U given the state w∈W of the world.
2.2 Bounded rational agents
In the information-theoretic model of bounded rationality (Ortega and Braun, 2011,
2013; Genewein et al., 2015), an agent isbounded rational if its posterior P maximizes
(1) subject to the constraint
⟨
DKL(P∥q)
⟩
=
∑
w∈W
ρ(w) DKL(P(·|w)∥q) ⩽ D0 , (2)
for a given bound D0 > 0 and a prior policy q ∈PA. Here, DKL(p∥q) denotes the
Kullback-Leibler (KL) divergence between two distributions p,q ∈ PY on a set Y,
deﬁned by DKL(p∥q) := ∑
y∈Yp(y) log(p(y)/q(y)). Note that, for DKL(p∥q) to be
well-deﬁned, pmust be absolutely continuous with respect toq, so thatq(y) = 0implies
p(y) = 0. When p or q are conditional probabilities, then we treat DKL(p∥q) as a
function of the additional variables.
Given a world statew, the information-processing consists of transforming a priorq
to a world state speciﬁc posterior distribution P(·|w). Since DKL(P(·|w)∥q) measures
by how much P(·|w) diverges from q, the upper bound D0 in (2) characterizes the
limitation of the agent’s average information-processing capability: If D0 is close to
zero, the posterior must be close to the prior for all world states, which means that
A contains only little information about W, whereas if D0 is large, the posterior is
allowed to deviate from the prior by larger amounts and therefore A contains more
information about W. We use the KL-divergence as a proxy for any resource measure,
as any resource must be monotone in processed information, which is measured by the
KL-divergence between prior and posterior.
Technically, maximizing expected utility under the constraint (2) is the same as
minimizing expected complexity cost under the constraint of a minimal expected per-
formance, where complexity is given by the expected KL-divergence between prior and
posterior and performance by expected utility. Minimizing complexity means minimiz-
ing the number of bits required to generate the actions.
2.3 Free Energy principle
By the variational method of Lagrange multipliers, the above constrained optimization
problem is equivalent to the unconstrained problem
max
P
(
⟨U⟩− 1
β
⟨
DKL(P∥q)
⟩)
, (3)
4
where β > 0 is chosen such that the constraint (2) is satisﬁed. In the literature on
information-theoretic bounded rationality (Ortega and Braun, 2011, 2013), the objective
in (3) is known as the Free EnergyFof the corresponding decision-making process. In
this form, the optimal posterior can be explicitly derived by determining the zeros of the
functional derivative ofFwith respect to P, yielding the Boltzmann-Gibbs distribution
P(a|w) = 1
Z(w) q(a) eβU(a,w) , Z (w) :=
∑
a∈A
q(a) eβU(a,w) . (4)
Note how the Lagrange multiplier β (also known as inverse temperature) interpolates
between an agent with zero processing capability that always acts according to its prior
policy (β = 0) and a perfectly rational agent ( β →∞). Note that, plugging (4) back
into the Free Energy (3) gives
max
P
F[P] = 1
β
⟨
log Z
⟩
. (5)
2.4 Optimal prior
The performance of a given bounded rational agent crucially depends on the choice of
the prior policy q. Depending on D0 and the explicit form of the utility function, it
can be advantageous to a priori prefer certain actions over others. Therefore, optimal
bounded rational decision-making includes optimizing the prior in (3). In contrast to
(3), the modiﬁed optimization problem
max
P,q
(
⟨U⟩− 1
β
⟨
DKL(P∥q)
⟩)
(6)
does not have a closed form solution. However, since the objective is convex in (P,q),
a unique solution can be obtained iteratively by alternating between ﬁxing one and op-
timizing the other variable (Csisz´ar and Tusn´ady, 1984), resulting in a Blahut-Arimoto
type algorithm (Arimoto, 1972; Blahut, 1972) that consists of alternating the equations
{
P(a|w) = 1
Z(w) q(a) eβU(a,w) ,
q(a) = p(a) = ∑
wρ(w)P(a|w),
(7)
with Z(w) given by (4). In particular, the optimal prior policy is the marginal pof the
joint distribution of W and A. In this case, the average Kullback-Leibler divergence
between prior and posterior coincides with the mutual information between W and A,
I(W; A) =
∑
w∈W
∑
a∈A
p(w,a) log p(w,a)
ρ(w)p(a) =
⟨
DKL(P,p)
⟩
.
It follows that the modiﬁed optimization principle (6) is equivalent to
max
P
(
⟨U⟩− 1
β I(W; A)
)
. (8)
Due to its equivalence to rate distortion theory (Shannon, 1959) (with a negative
distortion measure given by the utility function), (8) is denoted as the rate distortion
case of bounded rationality in (Genewein and Braun, 2013).
5
2.5 Multi-step and multi-agent systems
When multiple random variables are involved in a decision-making process, such a
process constitutes a multi-step system (see Section 3). Consider the case of a prior
over Athat is conditioned on an additional random variable X with values x∈X, i.e.
q(·|x) ∈PAfor all x∈X. Remember that we introduced a bounded rational agent as
a decision-making unit, that, after observing a world state w, transforms a single prior
policy over a choice space Ato a posterior policy P(·|w) ∈PA. Therefore, in the case
of a conditional prior, the collection of prior policies {q(·|x)}x∈X can be considered as
a collection or ensemble of agents, or a multi-agent system, where for a given x ∈X ,
the prior q(·|x) is transformed to a posterior P(·|x,w) ∈PA by exactly one agent.
Note that a single agent deciding about both, X and A, would be modelled by a prior
of the form q(x,a) with x∈X and a∈A, instead.
Hence, in order to combine multiple bounded rational agents, we are ﬁrst splitting
the full decision-making process into multiple steps by introducing additional interme-
diate random variables (Section 3), which then will be used to assign one or more agents
to each of these steps (Section 4). In this view, we can regard a multi-agent decision-
making system as performing a sequence of successive decision steps until an ultimate
action is selected.
3 Multi-step bounded rational decision-making
3.1 Decision nodes
Let W and Adenote the random variables describing the full decision-making process
for a given utility function U : W×A → R, as described in Section 2. In order
to separate the full process into N >1 steps, we introduce internal random variables
X1, . . . ,XN−1, which represent the outputs of additional intermediate bounded rational
decision-making steps. For each k, let Xk denote the target space and xk ∈Xk a partic-
ular value of Xk. We call a random variable that is part of a multi-step decision-making
system a (decision) node. For simplicity, we assume that all intermediate random vari-
ables are discrete (just like W and A).
Here, we are treating feed-forward architectures originating at X0 := W and ter-
minating in XN := A. This allows to label the variables {Xk}N
k=0 according to the
information ﬂow, so that Xj potentially can only obtain information about Xi if i < j.
The canonical factorization
p(w,x1,...,x N−1,a) =ρ(w) p(x1|w) p(x2|x1,w) ···p(a|xN−1,...,x 1,w)
of the joint probability distribution of {Xk}N
k=0 therefore consists of the posterior poli-
cies of each decision node.
3.2 Two types of nodes: inputs and prior selectors
A speciﬁc multi-step architecture is characterized by specifying the explicit depen-
dencies on the preceding variables for each node’s prior and posterior, or better the
6
W
X1
X2
X3
X4
A
p(x3|x1) − →p(x3|x2, x1)
Figure 1. Example of a processing node that is part of a multi-step architecture with
N = 5, visualized as a directed graph. Here, X3 processes the output of X2 by trans-
forming a prior policy p(x3|x1) to a posterior policy P(x3|x2,x1). The prior of X3
being conditioned on the output of X1 (indicated by the dashed arrow), means that X1
determines which of the prior policies {p(·|x1)}x1∈X1 is used by X3 to process a given
output of X2.
missing dependencies. For example, in a given multi-step system, the posterior of the
node X3 might depend explicitly on the outputs of X1 and X2 but not on W, so that
P(x3|x2,x1,w) =P(x3|x2,x1). If its prior has the form q(x3|x1), then X3 has to pro-
cess the output of X2. Moreover, in this case, the actual prior policy q(·|x1) ∈PX3 that
is used by X3 for decision-making is selected by X1 (see Figure 1).
In general, the inputs Xi,...,X j that have to be processed by a particular node Xk,
are given by the variables in the posterior that are missing from the prior, and, if its prior
qis conditioned on the outputs ofXl,...,X m, then these nodes select which of the prior
policies {q(·|xl,...,x m)}xl∈Xl,...,xm∈Xm ⊂PXk is used by Xk for decision-making, i.e.
for the transformation
q(xk|xl,...,x m) −→P(xk|xl,...,x m,xi,...,x j) .
We denote the collection of input nodes of Xk by Xk
in (:= {Xi,...,X j}) and the prior
selecting nodes of Xk by Xk
sel (:= {Xl,...,X m}). The joint distribution of X0,...,X N
is then given by
p(x0,...,x N) =ρ(w) P1
(
x1
⏐⏐x1
sel,x1
in
)
···PN
(
xN
⏐⏐xN
sel,xN
in
)
(9)
for all xk ∈Xk and xk
sel ∈Xk
sel, xk
in ∈Xk
in (k= 1,...,N ).
Specifying the sets Xk
sel and Xk
in of selectors and inputs for each node in the system
then uniquely characterizes a particular multi-step decision-making system. Note that
we always have (X1
sel,X1
in) = ({},{X0}).
Decompositions of the form (9) are often visualized by directed acyclic graphs, so-
called DAGs (see e.g. Bishop, 2006, pp. 360). Here, in addition to the decomposition
of the joint in terms of posteriors, we have added the information about the prior depen-
dencies in terms of dashed arrows, as shown in Figure 1.
7
3.3 Multi-step Free Energy principle
If Pk and qk denote the posterior and prior of the k-th node of an N-step decision-
process, then the Free Energy principle takes the form
sup
P1,q1,...,PN,qN
(
⟨U⟩−
N∑
k=1
1
βk
⟨
DKL(Pk∥qk)
⟩)
, (10)
where, in addition to the expectation over inputs, the average of DKL(Pk∥qk) now also
includes the expectation with respect to Xsel,
⟨
DKL(P∥q)
⟩
=
∑
xsel,xin
p(xsel,xin) DKL
(
P(·|xsel,xin)∥q(·|xsel)
)
.
Since the prior policies only appear in the KL-divergences, and moreover, there is
exactly one KL-divergence per prior, it follows as in 2.4, that for eachk= 1,...,N the
optimal prior is the marginal given for all xk ∈Xk by
qk(xk|xsel) =pk(xk|xsel) := 1
p(xsel)
∑
{x0,...,xN}\({xk}∪xsel)
p(x0,...,x N) , (11)
whenever Xk
sel = xsel. Hence, the Free Energy principle can be simpliﬁed to
sup
P1,...,PN
(
⟨U⟩−
N∑
k=1
1
βk
I
(
Xk
in; Xk
⏐⏐Xk
sel
))
, (12)
where I(X; Y|Z) denotes the conditional mutual information of two random variables
X,Y given a third random variable Z.
By optimizing (12) alternatingly, i.e. optimizing one posterior at a time while keep-
ing the others ﬁxed, we obtain for each k= 1,...,N ,
Pk
(
xk|xsel,xin
)
= pk
(
xk|xsel
)
Zk(xsel,xin) exp
[
βkFk[P1,...,P N](xk,xsel,xin)
]
, (13)
whenever Xk
sel = xsel and Xk
in = xin. Here, Zk(xsel,xin) denotes the normaliza-
tion constant and Fk[P1,...,P N] denotes the (effective) utility function on which the
decision-making in Xk is based on. More precisely, given ˜X = (Xk,Xk
sel,Xk
in),
it is the Free Energy of the subsequent nodes in the system, i.e. for any value of
˜x:= (xk,xsel,xin) we obtain for Fk := Fk[P1,...,P N],
Fk(˜x) = 1
p(˜x)
∑
{x0,...,xN}\˜x
p(x0,...,x N) Fk,loc(x0,...,x N) , (14)
where
Fk,loc(x0,...,x N) := U(x0,xN) −
∑
i>k
1
βi
log Pi(xi|xi
sel,xi
in)
pi(xi|xi
sel) .
Here, xi
in and xi
sel are collections of values of the random variables in Xi
in and Xi
sel,
respectively. The ﬁnal Blahut-Arimito-type algorithm consists of iterating (13), (11),
and (14) for each k= 1,...,N until convergence is achieved. Note that, since each op-
timization step is convex (marginal convexity), convergence is guaranteed but generally
not unique (Jain and Kar, 2017), so that, depending on the initialization, one might end
up in a local optimum.
8
3.4 Example: two-step information-processing
The cases ofserial and parallel information-processing studied in (Genewein and Braun,
2013), are special cases of multi-step decision-making systems introduced above. Both
cases are two-step processes ( N = 2) involving the variables X0 = W, X1 = X, and
X2 = A. The serial case is characterized by (X2
sel,X2
in) = ({},{X1}), and the parallel
case by (X2
sel,X2
in) = ({X1},{X0}). There is a third possible combination for N = 2,
given by (X2
sel,X2
in) = ({},{X0,X1}). However, it can be shown that this case is
equivalent to the (one-step) rate distoration case from Section 2, because ifAhas direct
world state access, then any extra input to the ﬁnal node A = X2, that is not a prior
selector, contains redundant information.
4 Systems of bounded rational agents
4.1 From multi-step to multi-agent systems
As explained in 2.5 above, a single random variable Xk that is part of an N-step
decision-making system can represent a single agent or a collection of multiple agents,
depending on the cardinality of Xk
sel, i.e. whether Xk has multiple priors which are
selected by the nodes in Xk
sel or not. Therefore, an N-step bounded rational decision-
making system with N >1 represents a bounded rational multi-agent system (of depth
N).
For a given k∈{1,...,N }, each value x∈Xk
sel of Xk
sel corresponds to exactly one
agent in Xk. During decision-making, the agents that belong to the nodes in Xk
sel are
choosing which of the |Xk
sel|agents in Xk is going to receive a given input xin (see 4.4
below for a detailed example). This decision is based on how well the selected agent
xwill perform on the input xin by transforming its prior policy pk(·|x) into a posterior
policy Pk( ·|x,xin), subject to the constraint
⟨DKL(Pk||pk)⟩(x) :=
∑
xin
p(xin|x) DKL
(
Pk(·|x,xin)∥pk(·|x)
)
⩽ Dx, (15)
where Dx >0 is a given bound on the agent’s information-processing capability. Sim-
ilarly to multi-step systems, this choice is based on the performance measured by the
Free energy of the subsequent agents.
4.2 Multi-agent Free Energy principle
In contrast to multi-step decision-making, the information-processing bounds are al-
lowed to be functions of the agents instead of just the nodes, resulting in an extra La-
grange multiplier for each agent in the Free Energy principle (10). As in (12), optimiz-
ing over the priors yields the simpliﬁed Free Energy principle
sup
P1,...,PN
(
⟨U⟩−
N∑
k=1
∑
xk
sel∈Xk
sel
p(xk
sel)
βk(xk
sel) I
(
Xk
in; Xk
⏐⏐Xk
sel = xk
sel
))
, (16)
9
which can be solved iteratively as explained in the previous section, the only difference
being that the Lagrange parameters βk now depend on xk
sel. Hence, for the posterior of
an agent that belongs to node k, we have
Pk
(
xk|xsel,xin
)
= pk
(
xk|xsel
)
Zk(xsel,xin) exp
[
βk(xk
sel) Fk(xk,xsel,xin)
]
, (17)
where βk(xk
sel) is chosen such that the constraint (15) is fulﬁlled for all x ∈xk
sel, and
Fk is given by (14) except that now we have
Fk,loc(x0,...,x N) := U(x0,xN) −
∑
i>k
1
βi(xi
sel) log Pi(xi|xi
sel,xi
in)
pi(xi|xi
sel) . (18)
The resulting Blahut-Arimoto-type algorithm is summarized in Algorithm 1.
Algorithm 1Blahut-Arimito-type algorithm for (16)
1: procedure GET MULTIAGENT SOLUTION (U,ρ, {(Xk
sel,Xk
in)}N
k=1,β,ϵ )
2: initialize p(x0,...,x N) ∀x0,...,x N,
3: repeat
4: p0 ←p
5: for k= 1,...,N do
6: Fk(xk,xsel,xin) ←(14),(18) ∀xk,xsel,xin ⊿calc. effective utility
7: Pk(xk|xsel,xin) ←(17) ∀xk,xsel,xin ⊿update posterior
8: p(xk|xsel) ←(11) ∀xk,xsel ⊿update prior
9: p(x0,...,x N) ←(9) ∀x0,...,x N ⊿update joint
10: end for
11: error ←dist(p,p0)
12: until error <ϵ
13: return P1,...,P N
14: end procedure
4.3 Specialization
Even though a given multi-agent architecture predetermines the underlying set of choices
for each agent, only a small part of such a set might be used by a given agent in the op-
timized system. For example, all agents in the ﬁnal step potentially can perform any
action a ∈A (see Figure 2 and the Example in 4.4 below). However, depending on
their indiviual information-processing capabilities, the optimization over the agents’
priors can result in a (soft) partitioning of the full action space Ainto multiple chunks,
where each of these chunks is given by the support of the prior of a given agent x,
supp(p(·|x)) ⊂ A. Note that the resulting partitioning is not necessarily disjoint,
since agents might still be sharing a number of actions, depending on their available
information-processing resources. If the processing capability is low compared to the
amount of possible actions in the full space, and if there are enough agents at the same
level, then this partitioning allows each agent to focus on a smaller number of options
10
to choose from, provided that the coordinating agents have enough resources to decide
between the partitions reliably.
Therefore, the amount of prior adaptation of an agent, i.e. by how much its optimal
prior pdeviates from a uniform prior p0 over all accessible choices, which is measured
by the KL-divergence DKL(p∥p0), determines its degree of specialization. More pre-
cisely, we deﬁne the specialization of an agent with prior pand choice space Xby
S[p] := DKL(p∥p0)
log |X| = 1− H[p]
log |X|, (19)
where H[p] := −∑
xp(x) logp(x) denotes the Shannon entropy of p. By normalizing
with log |X|, we obtain a quantity between 0 and 1, since 0 ⩽ H(p) ⩽ log |X|. Here,
S[p] = 0 corresponds to H[p] = log|X|, which means that the agent is completely
unspecialized, whereas S[p] = 1corresponds to H[p] = 0, which implies that p has
support on a single option x∗ ∈X meaning that the agent deterministically performs
always the same action and therefore is fully specialized.
world
agent
action
input
selection
W
X1
X2
A
Figure 2. Example of a hierarchical architecture of 10 agents that are combined via
the 3-step decision-making system (N = 3) shown in the upper left corner (see 4.4 for
details). Here, every node—and therefore every agent—has access to the world states
(big circle). X1 consists of one agent that decides about which of the|X1|= 3agents in
X2 obtains a given world state as input. The selected agent in X2 selects which of the
|X2|= 2agents out of the |X1|·|X2|= 6agents in Athat are connected to it, obtains
the world state to perform the ﬁnal decision about an action a∈A (grey circles on the
right). In our notation introduced below, this architecture is labelled by (1,4)[1,3,(3,2)]
(see Section 5.1).
11
4.4 Example: Hierarchical multi-agent system with three levels
Consider the example of an architecture of 10 agents shown in Figure 2 that are com-
bined via the 3-step decision-making system given by
(X2
sel,X2
in) = ({X1},{W}), (X3
sel,X3
in) = ({X1,X2},{W}), (20)
as visualized in the upper left corner of Figure 2. The number of agents in each node
is given by the cardinality of the target space of the selecting node(s) (or equals one if
there are no selectors). Hence, X1 consists of one agent, X2 consists of |X1|agents, and
Aconsists of |X1|·|X2|agents. For example, if we have |X1|= 3and |X2|= 2, as in
Figure 2, then this results in a hierarchy of 1,3 and 6 agents.
The joint probability of the system characterized by (20) is given by
p(w,x1,x2,a) =p(w)P1(x1|w)P2(x2|x1,w)P3(a|x2,x1,w) ,
and the Free Energy by
F[P1,P2,P3] =
∑
w,x1,x2,a
p(w,x1,x2,a)
[
U(a,w) − 1
β1
log P1(x1|w)
p1(x1)
− 1
β2(x1) log P2(x2|x1,w)
p2(x2|x1) − 1
β3(x1,x2) log P3(a|x2,x1,w)
p3(a|x2,x1)
]
,
where the priors p1, p2, and p3 are given by the marginals (11), i.e.
p1(x1) =
∑
w
ρ(w)P(x1|w) ,
p2(x2|x1) =
∑
w
p(w|x1)P2(x2|x1,w) ,
p3(a|x2,x1) =
∑
w
p(w|x1,x2)P3(a|x2,x1,w).
By (13), the posteriors that iteratively solve the Free Energy principle are
P1(x1|w) = p1(x1)
Z(w) exp
[
β1F1(w,x1)
]
,
P2(x2|x1,w) = p2(x2|x1)
Z(w,x1) exp
[
β2(x1)F2(w,x1,x2)
]
,
P3(a|x2,x1,w) = p3(a|x2,x1)
Z(w,x1,x2) exp
[
β3(x1,x2)U(a,w)
]
,
where, by (14) and (18),
F1(w,x1) :=
∑
x2,a
p(x2,a|x1,w)
[
U(a,w) − 1
β2(x1) log P2(x2|x1,w)
p2(x2|x1)
− 1
β3(x1,x2) log P3(a|x2,x1,w)
p3(a|x2,x1)
]
,
F2(w,x1,x2) :=
∑
a
P3(a|x2,x1,w)
[
U(a,w) − 1
β3(x1,x2) log P3(a|x2,x1,w)
p3(a|x2,x1)
]
.
12
Given a world statew∈W, the agent in X1 decides about which of the three agents
in X2 obtains w as an input. This narrows down the possible choices for the selected
agent in X2 to two out of the six agents in A. The selected agent performs the ﬁnal
decision by choosing an actiona∈A. Depending on its degree of specialization, which
is a result of his own and the coordinating agents’ resources, this agent will choose his
action from a certain subset of the full space A.
5 Optimal Architectures
Here, we show how the above framework can be used to determine optimal architectures
of bounded rational agents. Summarizing the assumptions made in the derivations, the
multi-agent systems that we analyze must fulﬁll the following requirements:
(i) The information-ﬂow is feed-forward: An agent in Xk can obtain information
directly from another agent that belongs to Xm only if m<k .
(ii) Intermediate agents cannot be endpoints of the decision-making process: the
information-ﬂow always starts with the processing of W and always ends with
a decision a∈A.
(iii) A single agent is not allowed to have multiple prior policies: Agents are the small-
est decision-making unit, in the sense that they transform a prior to a posterior
policy over a set of actions in one step.
The performance of the resulting architectures is measured with respect to the ex-
pected utility they are able to achieve under a given set of resource constraints. To
this end, we need to specify (1) the objective for the full decision-making process, (2)
the number N of decision-making steps in the system, (3) the maximal number n of
agents to be distributed among the nodes, and (4) the individual resource constraints
{D1,...,D n}of those agents.
We illustrate the speciﬁcations (1)–(4) with a toy example in Section 5.2 by show-
casing and explicitly explaining the differences in performance of several architectures.
Moreover, we provide a broad performance comparison in Section 5.3, where we sys-
tematically vary a set of objective functions and resource constraints, in order to deter-
mine which architectural features most affect the overall performance. For simplicity,
in all simulations we are limiting ourselves to architectures with N ⩽ 3 nodes and
n⩽ 10 agents. In the following section, we start by describing how we characterize the
architectures conforming to the requirements (i)–(iii).
5.1 Characterization of architectures
Type. In view of property (ii) above, we can label any N-step decision-making
process by a tuple(i,j), which we call thetype of the architecture, whereicharacterizes
13
(−1, )
W A
(0, )
W
X
A
(1, )
W
X
A
(2, )
W
X
A
(0, 0)
W
X1
X2
A
(0, 1)
W
X1
X2
A
(0, 2)
W
X1
X2
A
(0, 3)
W
X1
X2
A
(0, 4)
W
X1
X2
A
(0, 5)
W
X1
X2
A
(1, 0)
W
X1
X2
A
(1, 1)
W
X1
X2
A
(1, 2)
W
X1
X2
A
(1, 3)
W
X1
X2
A
(1, 4)
W
X1
X2
A
(1, 5)
W
X1
X2
A
(2, 1)
W
X1
X2
A
(2, 2)
W
X1
X2
A
(2, 3)
W
X1
X2
A
(2, 4)
W
X1
X2
A
Figure 3. Overview of the resulting architectures for N ⩽ 3, each of them being
labelled by its type.
the relation between the ﬁrst N−1 variables W, X1, . . . ,XN−1, and jdetermines how
these variables are connected to XN = A.
For example, for N ⩽ 3, we obtain the types shown in Figure 3, wherei∈{0,1,2}
and j ∈{0,..., 5}represent the following relations:
i= 0 : (X2
sel,X2
in) = ({},{X1})
i= 1 : (X2
sel,X2
in) = ({X1},{W})
i= 2 : (X2
sel,X2
in) = ({},{W})
j = 0 : (X3
sel,X3
in) = ({},{X2})
j = 1 : (X3
sel,X3
in) = ({},{X1,X2})
j = 2 : (X3
sel,X3
in) = ({X1},{X2})
j = 3 : (X3
sel,X3
in) = ({X2},{X1})
j = 4 : (X3
sel,X3
in) = ({X1,X2},{W})
j = 5 : (X3
sel,X3
in) = ({X2},{W}) .
For example, the architecture shown in Figure 2 has the type (1,4). Correspondingly,
the two-step cases are labelled by(i,) for i∈{0,1,2}, and the one-step rate distoration
case by (−1,). Note that not every combination of i ∈{0,1,2}and j ∈{0,..., 5}
describes a unique system, e.g. (2,3) is equivalent to (2,2) when replacing X1 by
14
X2. Moreover, as mentioned above, (2,) is equivalent to (−1,), and similarly, (0,1) is
equivalent to (0,).
(0, 3)[1,1,8] (1, 0)[1,8,1]
(1, 2)[1,4,4] (1, 5)[1,3,6]
(2, 1)[1,1,1]
world
agent
action
input
selection
(2, 4)[1,1,(2,4)]
W
1
1
8 W
1
8
1
W
1
4
4 W
1
3
6
W
1
1
1 W
1
1
8
Figure 4.Visualization of exemplary 3-step multi-agent architectures speciﬁed by their
types and shapes.
Shape. After the number of nodes has been ﬁxed, the remaining property that charac-
terizes a given architecture is the number of agents per node. For most architectures
there are multiple possibilities to distribute a given amount of agents among the nodes,
even when neglecting individual differences in resource constraints. We call such a dis-
tribution a shape, denoted by [n1,n2,... ], where nk denotes the number of agents in
node k. Note that, not all architectures will be able to use the full amount of available
agents, most immanently the one-step rate distortion case ( 1 agent), or the two-step
serial-case (2 agents). For these systems, we always use the agents with the highest
available resources in our simulations.
For example, for N ⩽ 3 the resulting shapes for a maximum of n = 10agents are
as follows:
•[1] for (−1,), [1,1] for (0,), and [1,9] for (1,),
15
0 4 8 12 16 20 24
responses a
0
4
8
12
16
20
24phone calls w
Utility function U
0 4 8 12 16 20 24
responses a
0
4
8
12
16
20
24
Posterior of a single agent with 4 .6 bit
0.0
0.2
0.4
0.6
0.8
1.0
Figure 5.Utility function for Example 5.2 (left) and posterior policy of a single agent
with an information bound of4.6 bit (right). The set of phone callsW is partitioned into
three separate regions, corresponding to three different topics about which customers
might have complaints or questions. Each of these can be divided into two subcate-
gories of four customer calls each. For each phone call there is exactly one answer that
achieves the best result ( U = 1). Moreover, the responses that belong to one subcat-
egory of calls are also suitable for the other calls in that particular subcategory, albeit
slightly less effective ( U = 0.85) than the optimal answers. Similarly, the responses
that belong to the same topic of calls are still a lot better ( U = 0.7) than responses to
other topics (U = 0).
•[1,1,1] for (0,0) and (2,1),
•[1,1,8] for (0,2), (0,3), (0,5), (2,2),
•[1,1,(2,4)] and [1,1,(4,2)] for (0,4) and (2,4),
•[1,8,1] for (1,0) and (1,1),
•[1,4,4] for (1,2),
•[1,2,7],[1,3,6],[1,4,5],[1,5,4],[1,6,3],[1,7,2] for (1,3) and (1,5),
•[1,2,(2,3)] and [1,3,(3,2)] for (1,4),
where a tuple inside the shape means that two different nodes are deciding about the
agents in that spot, e.g. [1,1,(2,4)] means that there are 8 agents in the last node,
labeled by the values (x1,x2) ∈X1 ×X2 with |X1|= 2and |X2|= 4. In Figure 4, we
visualize one example architecture for each of the above 3-step shapes, except for the
shapes of type (1,4) of which one example is shown in Figure 2.
Together, the type (i,... ) and shape [n1,... ] uniquely characterize a given multi-
agent architecture, denoted by (i,... )[n1,...].
5.2 Example: Callcenter
Consider the operation of a company’s callcenter as a decision-making process, where
customer calls (world states) must be answered with an appropriate response (action)
in order to achieve high customer satisfaction (utility). The utility function shown in
Figure 5 on the left can be viewed as a simplistic model for a real-world callcenter of a
big company such as a communication service provider. In this simpliﬁcation, there are
16
24 possible customer calls that belong to three separate topics, for example questions
related to telephone, internet, or television, which can be further subdivided into two
subcategories, for example consisting of questions concerning the contract or problems
with the hardware. See the description of Figure 5 for the explicit utility values.
Handling all possible phone calls perfectly by always choosing the corresponding
response with maximum utility requires log2(24) ≈4.6 bit (see Figure 5). However, in
practice a single agent is usually not capable of knowing the optimal answers to every
single type of question. For our example this means that the callcenter only has access
to agents with information-processing capability less than 4.6 bit. It is then required
to organize the agents in a way so that each agent only has to deal with a fraction of
the customer calls. This is often realized by ﬁrst passing the phone call through several
ﬁlters in order to forward it to a specialized agent. Arranging these selector or ﬁlter units
in a strict hierarchy then corresponds to architectures of the form of (1,4) or (1,5) (see
below for a comparison of these two), where at each stage asingle operator selects how
a call is forwarded. In contrast, architectures of the form of (2,4) allow for multiple
independent ﬁlters working in parallel, for example realized by multiple trained neural
networks, where each is responsible for a particular feature of the call (for example,
one node deciding about the language of the call, and another node deciding about the
topic). In the following we do not discriminate between human and artiﬁcial decision-
makers, since both can qualify equally well as information-processing units.
Assume that there are n = 10 bounded rational agents available. Considering the
given utility function, the architectures(1,4)[1,3,(3,2)] (shown in Figure 2) and(1,5)[1,3,6]
(shown in Figure 4) might be obvious choices as they represent the hierarchical structure
of the utility function. With an information bound of 1.6 (≈log2(3)) bit for the ﬁrst
agent and 0.1 bit for the rest, the optimal prior policies for (1,5)[1,3,6] obtained by our
Free Energy principle are shown in Figure 6. We can see that, for this architecture, the
choice x1 of the agent at the ﬁrst step corresponds to the general topic of the phone call,
the decisions x2 of the three agents at the second stage correspond to the subcategory
on which one of the six agents at the ﬁnal stage is specialized to, who then makes the
decision about the ﬁnal response aby picking one of the four actions in the support of
its prior.
0.0 0.2
p(x1)
0
1
2
choices xi
0.0 0.2 0.4
p(x2|x1 = 0)
0
1
2
3
4
5
0.0 0.2 0.4
p(x2|x1 = 1)
0
1
2
3
4
5
0.0 0.2 0.4
p(x2|x1 = 2)
0
1
2
3
4
5
0.0 0.2
p(a|x2 = 0)
0
5
10
15
20
0.0 0.2
p(a|x2 = 1)
0
5
10
15
20
0.0 0.2
p(a|x2 = 2)
0
5
10
15
20
0.0 0.2
p(a|x2 = 3)
0
5
10
15
20
0.0 0.2
p(a|x2 = 4)
0
5
10
15
20
0.0 0.2
p(a|x2 = 5)
0
5
10
15
20
Figure 6. Optimal prior policies for each agent of the architecture (1,5)[1,3,6] with an
information bound of (D1,D2,...,D 10) = (1.6,0.1,..., 0.1).
17
(0, 3)[1,1,8] (1, 0)[1,8,1] (1, 4)[1,3,(3,2)] (1, 5)[1,3,6] (2, 4)[1,1,(2,4)]
0.0
0.2
0.4
0.6
0.8
⟨U⟩
(D1, D2, . . . , D10) = (1.6, 0.1, . . . ,0.1) [bit]
(0, 3)[1,1,8] (1, 0)[1,8,1] (1, 4)[1,3,(3,2)] (1, 5)[1,3,6] (2, 4)[1,1,(2,4)]
0.0
0.2
0.4
0.6
0.8
(D1, D2, D3, . . . , D10) = (1.0, 0.5, 0.1, . . . ,0.1) [bit]
Figure 7.Performance comparison under two different information bounds.
We can see in Figure 7 on the left that a hierarchical structure as in (1,5)[1,3,6] or
(1,4)[1,3,(3,2)] is indeed superior when comparing with the architecture (2,4)[1,1,(2,4)],
because there is no good selector for the second ﬁlter. We have also added two architec-
tures to the comparison that have a bottleneck of the information ﬂow at either end of the
decision-making process, (0,3)[1,1,8] and (1,0)[1,8,1] (see Figure 4 for a visualization),
which are performing considerably worse than the others: in(0,3)[1,1,8] the ﬁrst agent is
the only one who has direct contact to the customer and passes the ﬁltered information
on to everybody else, whereas in (1,0)[1,8,1] the customer talks to multiple agents, but
these cannot take any decisions but pass on the information to a ﬁnal decision node
who has to select from all possible options. Interestingly, as can be seen on the right
side of Figure 7, when changing the resource bounds such that the ﬁrst agent only has
D1 = 1bit instead of 1.6 and the second agent has D2 = 0.5 bit instead of 0.1, then the
strictly hierarchical architectures (1,5)[1,3,6] and (1,4)[1,3,(3,2)] are outperformed by the
architecture (2,4)[1,1,(2,4)], because their ﬁrst agent is not able to perfectly distinguish
between the three topics anymore. This is an ideal situation for (2,4)[1,1,(2,4)], since
here the total information-processing for ﬁltering the phone calls is split up efﬁciently
between the ﬁrst two agents in the system.
Note that (1,4) and (1,5) do not necessarily perform identically (as can be seen on
the right in Figure 7), even though the structure of the utility function might suggest that
it is ideal for (1,5)[1,3,6] to always have the optimal priors shown in Figure 6. However,
this crucially depends on the given information-processing bounds. In Figure 8, we
illustrate the difference between the two types in more detail, by showing the processed
information that can actually be achieved per agent in the respective architecture for an
information bound of D = (0.4,2.6,2.6,2.6,0.4,..., 0.4). When the ﬁrst agent in the
hierarchy has low capacity, then the rigid structure of (1,4) is penalized because the
agents at the second stage cannot compensate the errors of the ﬁrst agent, irrespectively
(1, 4)[1,3,(3,2)] (1, 5)[1,3,6]
0.0
0.2
0.4
0.6
0.8
1.0
⟨U⟩
1 2 3 4 5 6 7 8 9 10
agent i
0.0
0.5
1.0
1.5
2.0
2.5
DKL(Pi∥pi) [bit]
(1, 4)[1,3,(3,2)]
0 1 2 3 4 5 6 7 8 9
agent i
0.0
0.5
1.0
1.5
2.0
2.5
DKL(Pi∥pi) [bit]
(1, 5)[1,3,6)]
0 4 8 12 16 20 24
responses a
0
4
8
12
16
20
24phone calls w
(1, 4)[1,3,(3,2)]
0 4 8 12 16 20 24
responses a
0
4
8
12
16
20
24phone calls w
(1, 5)[1,3,6]
Performance Processed information Eﬀective policy p(a|w)
Figure 8.Demonstration of the difference between the two architectures (1,4)[1,3,(3,2)]
and (1,5)[1,3,6] for an information bound of D= (0.4,2.6,2.6,2.6,0.4,..., 0.4).
18
of their capacity. In contrast, for (1,5), the connection between the second stage and
the executing stage can be changed freely, which leads to ignoring the ﬁrst agent and
letting the three agents in the second stage determine the distribution of phone calls
completely. In this sense, (1,5) is more robust to errors in the ﬁrst ﬁlter than (1,4).
5.3 Systematic performance comparison
In this section, we move away from an explicit toy example to a broad performance
comparison of all architectures for N ⩽ 3, averaged over multiple types of utility func-
tions and a large number of resource constraints (as deﬁned below). In Section 6.1,
this is supplemented with an analysis of the architectural features that best explain the
performances.
0 5 10 15 20
0
5
10
15
20world states
U1 (diag iso sm)
0 5 10 15 20
0
5
10
15
20
U2 (diag iso mm)
0 5 10 15 20
0
5
10
15
20
U3 (diag noniso sm)
0 5 10 15 20
0
5
10
15
20
U4 (diag noniso mm)
0 5 10 15 20
0
5
10
15
20world states
U5 (samw iso sm)
0 5 10 15 20
0
5
10
15
20
U6 (samw iso mm)
0 5 10 15 20
0
5
10
15
20
U7 (samw noniso sm)
0 5 10 15 20
0
5
10
15
20
U8 (samw noniso mm)
0 5 10 15 20
actions
0
5
10
15
20world states
U9 (masw iso sm)
0 5 10 15 20
actions
0
5
10
15
20
U10 (masw iso mm)
0 5 10 15 20
actions
0
5
10
15
20
U11 (masw noniso sm)
0 5 10 15 20
actions
0
5
10
15
20
U12 (masw noniso mm)
Figure 9.Utility functions on which the performances are measured.
Objectives. We compare all possible architectures for twelve different utility func-
tions, {Uk}12
k=1, deﬁned on a world and action space of |W|= |A|= 20elements, and
we assume the same cardinality for the range of all hidden variables. Note that the car-
dinality of the target setXfor selector nodes X ∈Xsel is given by the number of agents
it decides about. In particular, we consider three kinds of utility functions (one-to-one,
many-to-one, one-to-many) that we vary in a 2×2 paradigm, where the ﬁrst dimension
19
(−1,),[1]
(0,2),[1,1,8]
(0,4),[1,1,(2,4)]
(0,4),[1,1,(4,2)]
(1,3),[1,2,7]
(1,3),[1,4,5]
(1,4),[1,2,(2,3)]
(1,4),[1,3,(3,2)]
(1,5),[1,2,7]
(1,5),[1,3,6]
(1,5),[1,4,5]
(1,5),[1,5,4]
(1,5),[1,6,3]
(1,5),[1,7,2]
(1,),[1,9]
(2,2),[1,1,8]
(2,4),[1,1,(2,4)]
0.0
0.1
0.2
0.3
0.4
0.5
Winning rate
All conditions
(0,4),[1,1,(2,4)]
(0,4),[1,1,(4,2)]
(1,3),[1,2,7]
(1,3),[1,4,5]
(1,4),[1,2,(2,3)]
(1,4),[1,3,(3,2)]
(1,5),[1,2,7]
(1,5),[1,3,6]
(1,5),[1,4,5]
(1,5),[1,5,4]
(1,5),[1,6,3]
(1,5),[1,7,2]
(1,),[1,9]
(2,2),[1,1,8]
(2,4),[1,1,(2,4)]
0.0
0.1
0.2
0.3
0.4
Winning rate
Same constraints for all agents
(−1,),[1]
(0,2),[1,1,8]
(0,4),[1,1,(2,4)]
(0,4),[1,1,(4,2)]
(1,3),[1,4,5]
(1,4),[1,2,(2,3)]
(1,4),[1,3,(3,2)]
(1,5),[1,2,7]
(1,5),[1,3,6]
(1,5),[1,4,5]
(1,5),[1,6,3]
(1,5),[1,7,2]
(1,),[1,9]
(2,2),[1,1,8]
(2,4),[1,1,(2,4)]
0.0
0.1
0.2
0.3
0.4
0.5
Winning rate
Same constraints for all agents but one
(−1,),[1]
(0,4),[1,1,(2,4)]
(0,4),[1,1,(4,2)]
(1,3),[1,4,5]
(1,4),[1,2,(2,3)]
(1,4),[1,3,(3,2)]
(1,5),[1,2,7]
(1,5),[1,3,6]
(1,5),[1,4,5]
(1,5),[1,5,4]
(1,5),[1,6,3]
(1,5),[1,7,2]
(1,),[1,9]
(2,2),[1,1,8]
(2,4),[1,1,(2,4)]
0.0
0.2
0.4
0.6
Winning rate
Same constraints for all agents but two
Wins
Figure 10.Proportion of conditions where the given architectures had the highest per-
formance, for all conditions, and separately for each of the three different schemes of
resource constraints.
is the number of maximum utility peaks (single, multiple) and the second dimension is
the range of utility values (binary, multi-valued). The utility functions are visualized in
Figure 9, where the three kinds of functions correspond to the three rows of the plot. A
one-to-one scenario applies to a needle-in-a-haystack situation where each world state
affords only a unique action, and vice versa each optimal action allows to uniquely iden-
tify the world state, for example an absolute identiﬁcation task. A many-to-one scenario
allows for abstractions in the world states, for example in categorization when multiple
instances are judged to belong to the same class (e.g. vegetables are boiled, fruit is eaten
raw). A one-to-many scenario allows for abstractions in the action space, for example
in hierarchical motor control when a grasp action can be performed in many different
ways.
Resource limitations.We are considering three schemes of resource constraints:
(i) Same constraints for all agents.
(ii) Same constraints for all agents but one, which has a higher limit than the other
agents.
(iii) Same constraints for all but two agents, which can have a different limit and have
higher limits than all the other agents.
For (i), we compare 20 sets of constraints {D0,D1,... }with Di equally spaced in
the range between 0 and 3 bits, for (ii) we compare 39 sets in the same range but the
high resource agent having 1, 2 and 3 bits, and for (iii) we allow 89 sets with similar
constraints than in (ii) but additional combinations for the second high-resource agent.
Simulation results.The performance of an architecture is given by its expected util-
ity with respect to a given objective and a given information bound as deﬁned above.
20
(−1,),[1]
(0,),[1,1]
(1,),[1,9]
(0,0),[1,1,1]
(0,2),[1,1,8]
(0,3),[1,1,8]
(0,4),[1,1,(2,4)]
(0,4),[1,1,(4,2)]
(0,5),[1,1,8]
(1,0),[1,8,1]
(1,1),[1,8,1]
(1,2),[1,4,4]
(1,3),[1,2,7]
(1,3),[1,3,6]
(1,3),[1,4,5]
(1,3),[1,5,4]
(1,3),[1,6,3]
(1,3),[1,7,2]
(1,4),[1,2,(2,3)]
(1,4),[1,3,(3,2)]
(1,5),[1,2,7]
(1,5),[1,3,6]
(1,5),[1,4,5]
(1,5),[1,5,4]
(1,5),[1,6,3]
(1,5),[1,7,2]
(2,1),[1,1,1]
(2,2),[1,1,8]
(2,4),[1,1,(2,4)]
0.0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
Average score
Average over all conditions
U1 U2 U3 U4 U5 U6 U7 U8 U9 U10 U11 U12
0.6
0.7
0.8
0.9
1.0
Average score
Average over all constraints – for each utility function
(2, 4)[1,1,(2,4)]
(1, 5)[1,3,6]
(1, 4)[1,3,(3,2)]
{0.1, ...,
0.1}
{0.2, ...,
0.2}
{0.3, ...,
0.3}
{0.4, ...,
0.4}
{0.5, ...,
0.5}
{0.6, ...,
0.6}
{0.7, ...,
0.7}
{0.8, ...,
0.8}
{0.9, ...,
0.9}
{1.0, ...,
1.0}
{1.1, ...,
1.1}
{1.2, ...,
1.2}
{1.3, ...,
1.3}
{1.4, ...,
1.4}
{1.5, ...,
1.5}
{1.6, ...,
1.6}
{1.7, ...,
1.7}
{1.8, ...,
1.8}
{1.9, ...,
1.9}
{2.0, ...,
2.0}
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
Average expected utility
Average over all utility functions – same constraint for all agents
(2, 4)[1,1,(2,4)]
(1, 5)[1,3,6]
(1, 4)[1,3,(3,2)]
{1.0,0.1, ...,
0.1}
{1.0,0.3, ...,
0.3}
{1.0,0.4, ...,
0.4}
{1.0,0.6, ...,
0.6}
{1.0,0.7, ...,
0.7}
{1.0,0.9, ...,
0.9}
{2.0,0.1, ...,
0.1}
{2.0,0.3, ...,
0.3}
{2.0,0.4, ...,
0.4}
{2.0,0.6, ...,
0.6}
{2.0,0.7, ...,
0.7}
{2.0,0.9, ...,
0.9}
{2.0,1.0, ...,
1.0}
{2.0,1.2, ...,
1.2}
{2.0,1.3, ...,
1.3}
{2.0,1.4, ...,
1.4}
{2.0,1.6, ...,
1.6}
{2.0,1.7, ...,
1.7}
{2.0,1.9, ...,
1.9}
{3.0,0.1, ...,
0.1}
{3.0,0.3, ...,
0.3}
{3.0,0.4, ...,
0.4}
{3.0,0.6, ...,
0.6}
{3.0,0.7, ...,
0.7}
{3.0,0.9, ...,
0.9}
{3.0,1.0, ...,
1.0}
{3.0,1.2, ...,
1.2}
{3.0,1.3, ...,
1.3}
{3.0,1.4, ...,
1.4}
{3.0,1.6, ...,
1.6}
{3.0,1.7, ...,
1.7}
{3.0,1.9, ...,
1.9}
{3.0,2.0, ...,
2.0}
{3.0,2.2, ...,
2.2}
{3.0,2.3, ...,
2.3}
{3.0,2.5, ...,
2.5}
{3.0,2.6, ...,
2.6}
{3.0,2.7, ...,
2.7}
{3.0,2.9, ...,
2.9}
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
Average expected utility
Average over all utility functions – same constraint for all agents but one
(2, 4)[1,1,(2,4)]
(1, 5)[1,3,6]
(1, 4)[1,3,(3,2)]
{1.0,1.0,0.1, ...,
0.1}
{1.0,1.0,0.3, ...,
0.3}
{1.0,1.0,0.4, ...,
0.4}
{1.0,1.0,0.6, ...,
0.6}
{1.0,1.0,0.7, ...,
0.7}
{1.0,1.0,0.9, ...,
0.9}
{1.0,2.0,0.1, ...,
0.1}
{1.0,2.0,0.3, ...,
0.3}
{1.0,2.0,0.4, ...,
0.4}
{1.0,2.0,0.6, ...,
0.6}
{1.0,2.0,0.7, ...,
0.7}
{1.0,2.0,0.9, ...,
0.9}
{1.0,3.0,0.1, ...,
0.1}
{1.0,3.0,0.3, ...,
0.3}
{1.0,3.0,0.4, ...,
0.4}
{1.0,3.0,0.6, ...,
0.6}
{1.0,3.0,0.7, ...,
0.7}
{1.0,3.0,0.9, ...,
0.9}
{2.0,1.0,0.1, ...,
0.1}
{2.0,1.0,0.3, ...,
0.3}
{2.0,1.0,0.4, ...,
0.4}
{2.0,1.0,0.6, ...,
0.6}
{2.0,1.0,0.7, ...,
0.7}
{2.0,1.0,0.9, ...,
0.9}
{2.0,2.0,0.1, ...,
0.1}
{2.0,2.0,0.3, ...,
0.3}
{2.0,2.0,0.4, ...,
0.4}
{2.0,2.0,0.6, ...,
0.6}
{2.0,2.0,0.7, ...,
0.7}
{2.0,2.0,0.9, ...,
0.9}
{2.0,2.0,1.0, ...,
1.0}
{2.0,2.0,1.2, ...,
1.2}
{2.0,2.0,1.3, ...,
1.3}
{2.0,2.0,1.4, ...,
1.4}
{2.0,2.0,1.6, ...,
1.6}
{2.0,2.0,1.7, ...,
1.7}
{2.0,2.0,1.9, ...,
1.9}
{2.0,3.0,0.1, ...,
0.1}
{2.0,3.0,0.3, ...,
0.3}
{2.0,3.0,0.4, ...,
0.4}
{2.0,3.0,0.6, ...,
0.6}
{2.0,3.0,0.7, ...,
0.7}
{2.0,3.0,0.9, ...,
0.9}
{2.0,3.0,1.0, ...,
1.0}
{2.0,3.0,1.2, ...,
1.2}
{2.0,3.0,1.3, ...,
1.3}
{2.0,3.0,1.4, ...,
1.4}
{2.0,3.0,1.6, ...,
1.6}
{2.0,3.0,1.7, ...,
1.7}
{2.0,3.0,1.9, ...,
1.9}
{3.0,1.0,0.1, ...,
0.1}
{3.0,1.0,0.3, ...,
0.3}
{3.0,1.0,0.4, ...,
0.4}
{3.0,1.0,0.6, ...,
0.6}
{3.0,1.0,0.7, ...,
0.7}
{3.0,1.0,0.9, ...,
0.9}
{3.0,2.0,0.1, ...,
0.1}
{3.0,2.0,0.3, ...,
0.3}
{3.0,2.0,0.4, ...,
0.4}
{3.0,2.0,0.6, ...,
0.6}
{3.0,2.0,0.7, ...,
0.7}
{3.0,2.0,0.9, ...,
0.9}
{3.0,2.0,1.0, ...,
1.0}
{3.0,2.0,1.2, ...,
1.2}
{3.0,2.0,1.3, ...,
1.3}
{3.0,2.0,1.4, ...,
1.4}
{3.0,2.0,1.6, ...,
1.6}
{3.0,2.0,1.7, ...,
1.7}
{3.0,2.0,1.9, ...,
1.9}
{3.0,3.0,0.1, ...,
0.1}
{3.0,3.0,0.3, ...,
0.3}
{3.0,3.0,0.4, ...,
0.4}
{3.0,3.0,0.6, ...,
0.6}
{3.0,3.0,0.7, ...,
0.7}
{3.0,3.0,0.9, ...,
0.9}
{3.0,3.0,1.0, ...,
1.0}
{3.0,3.0,1.2, ...,
1.2}
{3.0,3.0,1.3, ...,
1.3}
{3.0,3.0,1.4, ...,
1.4}
{3.0,3.0,1.6, ...,
1.6}
{3.0,3.0,1.7, ...,
1.7}
{3.0,3.0,1.9, ...,
1.9}
{3.0,3.0,2.0, ...,
2.0}
{3.0,3.0,2.2, ...,
2.2}
{3.0,3.0,2.3, ...,
2.3}
{3.0,3.0,2.5, ...,
2.5}
{3.0,3.0,2.6, ...,
2.6}
{3.0,3.0,2.7, ...,
2.7}
{3.0,3.0,2.9, ...,
2.9}
Information-processing constraints [bits]
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
Average expected utility
Average over all utility functions – same constraint for all agents but two
(2, 4)[1,1,(2,4)]
(1, 5)[1,3,6]
(1, 4)[1,3,(3,2)]
Figure 11.Architecture performances averaged over all conditions (ﬁrst row), averaged
over all information bounds for each utility function (second row), and averaged over
all objectives for each information bound (last three rows).
21
In Figure 10, we show which of the architectures won at least one condition, together
with the proportion of conditions won by each of these architectures. We can see that
(2,4)[1,1,(2,4)] overall outperforms all the other systems (see Figure 4 for a visualiza-
tion). In the case when all agents have the same resource constraints, the architecture
(1,4)[1,3,(3,2)] is a strong second winner, however this is not the case if one or two agents
have more resources than the rest. It is not surprising that in these situations the parallel
case with one high-resource agent distributing the work among the low resource agents,
and even the case of a single agent that does everything by himself, are both performing
well.
A closer look on the achieved expected utilities however, shows that there are several
architectures that are almost equally well performing for many conditions. In order to
increase comparability between the different utility functions, we measure performance
in terms of a relativescore, which, for a given utility function and resource constraint, is
given by the architectures’ expected utility divided by the maximum expected utility of
all architectures. The score averaged over all conditions is shown for each architecture
in Figure 11 in the top row. We can see that the best architectures are pretty close to each
other. As expected, the architecture that won the most conditions also has the highest
overall performance, however there are multiple architectures that are very close. The
top three architectures are
(2,4)[1,1,(2,4)], (1,5)[1,3,6], (1,4)[1,3,(3,2)], (21)
which have been visualized above (Figure 2 and 4).
A better understanding of their performances under different resource constraints
can be gathered from the remaining graphs in Figure 11. In the second row we can
see that the top three overall architectures also perform best for almost all utility func-
tions when averaged over the information bounds. The last three graphs in Figure 11
show the expected utility of each architecture averaged over all utility functions for each
information bound. We can see how the expected utility increases with higher informa-
tion bounds, for some architectures more than for others. The top three architecures
perform differently for most of the bounds, with spans of bounds where each of them
clearly outperforms the others.
6 Discussion
6.1 Analysis of the simulations
There are plenty of factors that inﬂuence the performance of each of the given architec-
tures. Here, we attempt to unfold the features that determine their performances in the
clearest way. To this end, we compare the architectures with respect to the following
quantities:
Average specialization of operational agents: the specialization (19) averaged over
all agents in the ﬁnal stage of the architecture.
Hierarchical: boolean value that speciﬁes whether an architecture is hierarchical
or not, meaning that consecutive nodes are occupied by an increasing amount of
agents.
22
Agents with direct w-access: the number of agents with direct world state access.
operational agents with direct w-access: the number of agents in the last node of
the architecture.
Number of w-bottlenecks: the total number of nodes that are missing direct access
to the world state.
0.00
0.25
0.50
0.75
1.00
Scores
0.0
0.2
0.4
0.6
0.8
Average specialization of executing agents
0.00
0.25
0.50
0.75
1.00
Hierarchical
0.0
2.5
5.0
7.5
10.0
Agents with direct w-access
0
2
4
6
8
Executing agents with direct w-access
(2, 4),[1, 1, (2, 4)](1, 5),[1, 3, 6](1, 4),[1, 3, (3, 2)](1, 5),[1, 2, 7](1, 5),[1, 4, 5](1, 4),[1, 2, (2, 3)](1, 5),[1, 5, 4](1, 5),[1, 6, 3](1,),[1, 9](1, 5),[1, 7, 2](0, 4),[1, 1, (4, 2)](2, 2),[1, 1, 8](0, 4),[1, 1, (2, 4)](-1,),[1](0, 5),[1, 1, 8](1, 3),[1, 2, 7](1, 3),[1, 3, 6](1, 3),[1, 4, 5](1, 2),[1, 4, 4](1, 3),[1, 5, 4](1, 3),[1, 6, 3](0, 2),[1, 1, 8](1, 3),[1, 7, 2](2, 1),[1, 1, 1](1, 1),[1, 8, 1](0, 3),[1, 1, 8](1, 0),[1, 8, 1](0,),[1, 1](0, 0),[1, 1, 1]
0.0
0.5
1.0
1.5
2.0
Number of w-bottlenecks
Figure 12.Proposed features to explain the architectures’ performances (see 6.1).
As can be seen from Figure 12, we found that these architectural features explain the
differences in performance quite well. More precisely, the architectures can be roughly
grouped into three different categories, indicated by slightly different color saturations
in Figure 12): The poorest performing group consists of architectures that have between
one and two w-bottlenecks, and therefore have only few agents with direct w-access,
in particular none of their operational agents has direct w-access. Moreover, in this
group, most architectures are not hierarchical at all, and their operational agents have
low specialization, with two exceptions that both have two w-bottlenecks.
23
The architectures with medium performance have maximally one w-bottleneck and
many of them are hierarchical. Here, those systems that have operational units with
high specialization are missing direct w-access, and the systems that have operational
units with direct w-access have low specialization.
All architectures in the top group have many agents with direct world-state access
and they have no w-bottlenecks. Interestingly, the best six architectures are all strictly
hierarchical. Moreover, the order of performance is almost in direct accordance with
the average specialization of the operational agents.
Overall we can say that, it is best to have as many operational units as needed
to discriminate the actions well, as long as the coordinating agents have enough re-
sources to discriminate between them properly. The architecture(1,4)[1,1,(2,4)] has eight
operational agents, which are managed by two coordinating units, which need maxi-
mally two bits (for choosing among four agents) and one bit (for choosing among two
agents) in order to perform well. Both of the other top three architectures, (1,5)[1,3,6]
and (1,4)[1,3,(3,2)], have six operational agents, which are managed by three coordinat-
ing units, so that each of them needs maximally one bit. But compared to(1,4)[1,1,(2,4)],
there are less agents to spare for the operational stage. Hence, if the operational units
have low resources, it is always a trade-off between the number of operational units and
the resources of the coordinating ones.
Another way to see why the architecture (1,4)[1,1,(2,4)] overall outperforms all the
other high-ranked systems, might be its lower average choice-per-agent ratio, i.e. the
average number options for the decision of each agent in the system. In (1,4)[1,1,(2,4)],
the second agent also directly observes the world state, and moreover, the choice space
of eight agents at the operational stage is split into two and four choices. Therefore,
there are only 2+4+20
10 = 2.6 choices per agent on average, whereas for (1,5)[1,3,6] and
(1,4)[1,3,(3,2)], there are 3+6+20
10 = 2.9.
6.2 Limitations of our analysis
The analysis presented above only provides a rough explanation of the differences in
performance. Which architecture is optimal, depends a lot on the actual information
bounds of each agent. In all of our conditions, we assumed that most agents have the
same processing capabilities, which is why there is a certain bias towards architectures
that perform well under this assumption (low variance in choice-per-agent ratio across
the agents).
Due to the large amount of Lagrange parameters in the Free Energy principle (16),
the data generation was done by running the Blahut-Arimoto-type algorithm for10.000
different combinations of parameters for each of the architectures, for each type of
the different types of resource limitations, (i)–(iii) in 5, and for each of the utility
functions deﬁned in 5. For a given information bound, the corresponding parameters
were determined by looking for the points with the highest Free Energy that still respect
the bound.A better approach would be to enhance the global parameter search by a more
ﬁne-grained local search. Another possibility is to use an evolutionary algorithm, where
each population is given by multiple sets of parameters and the information constraints
are built in by a method similar to (Chehouri et al., 2016). This works well but requires
signiﬁcantly more time to process.
24
Since the Blahut-Arimoto type algorithm is not guaranteed to converge to a global
maximum, the resulting values for the expected utility and mutual information for a
given set of parameters can depend on the initialization of the algorithm. In practice, this
variation is small enough, so that it inﬂuences the average performance over multiple
conditions only by a negligable amount. However, direct comparisons of architectures
for a given information bound and utility function should be repeated multiple times to
make sure that the results are stable.
6.3 Relation to Variational Bayes and Active Inference
Above, we determined the architectures that achieve the highest expected utility under a
given resource constraint. These constraints are fulﬁlled by tuning the Lagrange multi-
pliers in the Free Energy principle. If the Lagrange multipliers themselves are ﬁxed, for
instance as exchange rates between information and utility (Ortega and Braun, 2010),
or inverse temperatures in thermodynamics (Ortega and Braun, 2013), then the Free
Energy itself would be an appropriate performance measure. This is done, for example
in Bayesian model selection, which is also known as structure learning and represents
an important problem in Bayesian inference and machine learning. The Bayesian ap-
proach for evaluating different Bayesian network structures, in order to ﬁnd the relation
of a given set of hidden variables that best explains a dataset D, consists in comparing
the marginal likelihood or evidence p(D|S) of the structures S (Friedman and Koller,
2003). This can be seen to be analogous to a performance comparison of different
decision-making architectures measured by the Free Energy. In the simple case of one
observable Y and one hidden variable X, we have
p(y|S) =
∑
x∈X
p(x|S) p(y|x,S) ∀y∈Y ,
where the likelihood p(y|x,S) is assumed to be known. Given a prior p(x|S) and, for
simplicity, a single observed datapoint y ∈Y, the posterior distribution of X can be
inferred by using Bayes’ rule,
p(x|y,S) =p(x|S) p(y|x,S)
p(y|S) ∀x∈X . (22)
As has been noted before (Ortega and Braun, 2013), when comparing (22) with the
Boltzmann equation (4) we can see that (22) is equivalent to the posterior P of a
bounded rational decision-maker with choice space X, prior policy p(x|S), Lagrange
parameter β = 1, and utility function given by U(x) := log p(y|x,S). Since the
marginal likelihood p(y|S) is the normalization constant in (22), it follows immedi-
ately from (5) that log p(y|S) is the optimal Free Energy Fvar[P = p(·|y,S)] of this
25
decision-maker, where
Fvar[P] :=
∑
x
P(x) logp(y|x,S) −
∑
x
P(x) log P(x)
p(x|S)
=
∑
x
P(x) logp(x|y,S)
P(x) + logp(y|S)
=
∑
x
P(x) logp(x,y|S)
P(x) . (23)
In Bayesian statistics, Fvar is known as the variational Free Energy, and the given
decomposition is often referred to in terms of the difference between accuracy (ex-
pected log-likelihood) and complexity (KL-divergence between prior and posterior).
It is used in the variational characterization of Bayes’ rule, i.e. the approximation of
the exact Bayesian posterior p(·|y,S) given by (22) in terms of a simpler—for exam-
ple a parametrized—distribution q by minimizing the KL-divergence between q and
p(·|y,S). Since DKL(q∥p(·|y,S)) = −Fvar[q] + logp(y,S), this is equivalent to the
maximization of Fvar.
The same is true for multiple hidden variables. For example, let S be the 3-step
architecture of type (1,4) from Section 4.4 with W = Y and hidden variables X1,X2,
and X3 = A. Setting β1 = β2 = β3 = 1and U(a,x1,x2,y) = logp(y|a,x1,x2,S), we
obtain
F2(y,x1,x2) = logp(y|x1,x2,S) , F1(y,x1) = logp(y|x1,S) ,
and
Z(y,x1,x2) =p(y|x1,x2,S) , Z(y,x1) =p(y|x1,S) , Z(y) =p(y|S) .
Note that, even though so far we always assumed that the utility function only depends
on the world states and actions, the equations in Sections 3, 4, and 4.4 are also valid
in the general case of U depending on all the variables in the system. The total Free
Energy for a given y∈Y then takes the form
∑
x1,x2
p(x1,x2|y,S)
(
log p(y|x1,x2,S) −log p(x2|x1,y,S )
p(x2|x1,S) −log p(x1|y,S)
p(x1|S)
)
=
∑
x1
p(x1|y,S)
(
log p(y|x1,S) −log p(x1|y,S)
p(x1|S)
)
= logp(y|S) .
Hence, also in this case, the logarithm of the marginal likelihood is given by the Free
Energy of the corresponding decision-making system. Choosing the multi-step archi-
tecture with the highest Free Energy is then analogous to Bayesian model selection with
the marginal likelihood or Bayesian model evidence as performance measure.
Another interesting interpretation of (23) is that here the hidden variable X can be
thought of as an action causing observed outcomes y. This is close to the framework
of Active Inference (Friston et al., 2015b, 2017b), where actions directy cause transi-
tions of hidden states, which generate outcomes that are observed by the actor. More
precisely, there the real-world process generating observable outcomes is distinguished
26
from an internal generative model describing the beliefs about the external generative
process (e.g. a Markov decision process). Observations are generated from transitions
of hidden states, which depend on the decision-maker’s actions. Decision-making is
given by the optimization of a variational Free Energy analogous to (23), where the
log-likelihood is given by the generative model, which describes beliefs about the hid-
den and control states of the generative process. This way utilities are absorbed into a
(desired) prior (Ortega and Braun, 2015). There are several differences to our approach.
First, the structure of the Free Energy principle of bounded rationality originates from
the maximization of a given pre-deﬁned external utility function under information
constraints, whereas the Free Energy principle of Active Inference aims to minimize
surprise or Bayesian model evidence, effectively minimizing the divergence between
approximate and true posterior. Second, in Active Inference, utility is transformed into
preferences in terms of prior beliefs, while in bounded rationality prior policies over
actions can be part of the optimization process, which results in specialization and ab-
straction. In constrast, Active Inference compounds utilities and priors into a single
desired prior which is ﬁxed and does not allow to separately optimize utility and action
priors.
7 Conclusion
In this work, we have presented an information-theoretic framework to study systems
of decision-making units with limited information-processing capabilities. It is based
on an overreaching Free Energy optimization principle, which, on the one hand, allows
to compute the optimal performances of explicit architectures, and on the other hand,
produces optimal partitions of the involved choice spaces into regions of specialization.
In order to combine a given set of bounded rational agents, ﬁrst the full decision-making
process is split into multiple decision steps by introducing intermediate decision vari-
ables, and then a given set of agents is distributed among these variables. We have
argued that this leads to two types of agents, non-operational units that distribute the
work among subordinates, and operational units that are doing the actual work in the
sense of choosing a particular action that either serves as an input for another agent
in the system, or represents the ﬁnal decision of the full process. This “vertical” spe-
cialization is enhanced by optimizing over the agents’ prior policies, which leads to
an optimal soft partitioning of the underlying choice space of each step in the system,
resulting in a “horizontal” specialization as well.
In order to illustrate the proposed framework, we have simulated and analyzed the
performances under a number of different resource constraints and tasks for all possible
3-step architectures whose information ﬂow starts by observing a given world state and
ends with the selection of a ﬁnal decision. Even though the relative architecture perfor-
mances depend crucially on the explict information-processing constraints, the overall
best performing architectures tend to be hierarchical systems of non-operational “man-
ager” units at higher hierarchical levels and operational “worker” units at the lowest
level.
Our approach is based on earlier work on information-theoretic bounded rationality
27
(Ortega and Braun, 2011, 2013; Genewein and Braun, 2013; Genewein et al., 2015)
(see also the references therein). In particular, the N-step decision-making systems
introduced in Section 3 generalize the two-step processes studied in (Genewein and
Braun, 2013; Genewein et al., 2015). According to Simon (Simon, 1979), there are
three different bounded rational procedures that can transform intractable into tractable
decision problems: (i) Looking for satisfactory choices instead of optimal ones, (ii)
replacing global goals with tangible subgoals, and (iii) dividing the decision-making
task among many specialists. From this point of view, the decision-making process of
a single agent, given by the one-step case of information-theoretic bounded rationality
(Ortega and Braun, 2011, 2013) described in Section 2, corresponds to (i), while the
bounded rational multi-step and multi-agent decision-making processes introduced in
Section 3 and 4, can be attributed to (ii) and (iii).
The main advantage of a purely information-theoretic treatment is its universality.
To our knowledge this work is the ﬁrst systematic theory-guided approach to the organi-
zation of agents with limited resources in the generality of information theory. In other
approaches, more speciﬁc methods are used instead, that are tailored to each particular
focus of study. In particular, bounded rationality has usually a very speciﬁc meaning,
often being implemented by simply restricting the cardinality of the choice space. For
example, in management theory the well-known results by Graicunas from the 1930s
(Graicunas, 1933) suggest that managers must have a limited span of control in order
to be efﬁcient. By counting the number of possible relationships between managers
and their subordinates, he concludes that there is an explicit upper bound of ﬁve or
six subordinates. Of course, there are many cases of successful companies today that
disagree with Graicunas’ claim, e.g. Apple’s CEO has 17 managers that are reporting
directly to him. However, current management experts think that the optimal number
is somewhere between 5 and 12. The idea of restricting the cardinality of the space of
decision-making is also studied for operational agents. For example in (Camacho and
Persky, 1988), Camacho and Persky explore the hierarchical organization of specialized
producers with a focus on production. Even though their treatment is more abstract and
more general than many preceeding studies, their take on bounded rationality is very
explicit and based on the assumption that the number of elementary parts that form a
product, as well as the number of possibilities of each part, are larger than a single
individual can handle. Similarly, in most game theoretic approaches that are based on
automaton theory (Neyman, 1985; Abreu and Rubinstein, 1988; Hern ´andez and Solan,
2016), the boundedness of an agent’s rationality is expressed by a bound on the number
of states of the automaton. Most of these non-information theoretic treatments consider
cases when there is a hard upper bound on the number of options, but they usually lack a
probabilistic description of the behaviour in cases when the number of options is larger
than the given bound.
The work by Geanakoplos and Milgrom (1991) uses “information” to describe the
limited attention of managers in a ﬁrm. But here, the term is used more informally, and
not in the classical information-theoretical sense. However, one of their results suggests
that “ﬁrms with more prior information about parameters [...] will employ less able
managers, or give their managers wider spans of control” (Geanakoplos and Milgrom,
1991, p. 207). This observation is in line with information-theoretic bounded rationality,
since by optimizing over priors in the Free Energy principle, the required processing-
28
information is decreased compared to the case of non-optimal priors, so that less able
agents can perform a given task, or similarly, an agent with a higher information bound
can have a larger choice space.
In neuroscience, the variational Bayes approach explained in Section 6.3 has been
proposed as a theoretical framework to understand brain function in terms of Active
Inference (Friston, 2009, 2010; Friston et al., 2015a,b, 2017a,b), where perception is
modelled as variational Bayesian inference over hidden causes of observations. There,
a processing node (usually a neuron) is limited in the sense that it can only linearly
combine a set of input signals into a single output signal. Decision-making is mod-
elled by approximating Bayes’ rule in terms of these basic operations, and then tuning
the weights of the resulting linear transformations in order to optimize the Free En-
ergy (23). Hence, there, the Free Energy serves as a tool to computationally simplify
Bayesian inference on the neuronal level, whereas our Free Energy principle is a tool
to computationally trade off expected utility and processing costs, providing an abstract
probabilistic description of the best possible choices when the information-processing
capability is limited.
In the general setting of approximate Bayesian inference, there are many interesting
algorithms and belief update schemes, for example belief propagation in terms of mes-
sage passing on factor graphs (see e.g. Yedidia et al., 2005). These algorithms make use
of the notion of the Markov boundary (minimal Markov blanket) of a node X, which
consists of the nodes that share a common factor with X (so-called neighbours). Con-
ditioned on its Markov boundary a given random variable is independent of all other
variables in the system, which allows to approximate marginal probabilities in terms of
local messages between neighbours. These approximations are generally only exact on
tree-like factor graphs without loops (M ´ezard and Montanari, 2009, Thm. 14.1). This
raises the interesting question of whether such algorithms could also be applied to our
setting. First, it should be noted that variational Bayesian inference constitutes only
a subclass of problems that can be expressed by utility optimization with information
constraints. In this subclass, all random variables have to appear either in utility func-
tions, that is they have to be given as log-likelihoods, or they have to appear in marginal
distributions that are kept ﬁxed—see for example the deﬁnition of the utility in the in-
ference example above where U(a,x1,x2,y) = logp(y|a,x1,x2,S) compared to the
utility functions of the form U(w,a) used throughout the paper that leave all interme-
diate random variables X1,...,X N−1 unspeciﬁed. Second, while it may be possible to
exploit the notion of Markov blankets by recursively computing free energies between
the nodes in a similar fashion to message-passing, there can also be contributions from
outside the Markov boundary, for example when the action node has to take an expec-
tation over possible world states that lie outside the Markov boundary. Finally, it may
be interesting to study whether message passing algorithms can be extended to deal
with our general problem setting and at least to approximately generate the same kind
of solutions as Blahut-Arimoto, even though in general we do not have tree-structured
graphs.
There are plenty of other possible extensions of the basic framework introduced in
this work. Marschak and Reichelstein (1998) study multi-agent systems in terms of
communication cost minimization, while ignoring the actual decision-making process.
One could combine our model with the information bottleneck method (Tishby et al.,
29
1999) and explicitly include communication costs in order to study more general agent
architectures, in particular systems with non-directed information ﬂow. Moreover, we
have seen in our simulations that specialization of operational agents is an important
feature shared among all of the best performing architectures. In the biological liter-
ature, specialization is often paired with modularity. For example Kashtan and Alon
(2005) and Wagner et al. (2007) show that modular networks are an evolutionary con-
sequence of modularly varying goals. Similarly, it would be interesting to study the
effects of changing environments on specialization, abstraction, and optimal network
architectures of systems of bounded rational agents.
Acknowledgement
This study was funded by the European Research Council (ERC-StG-2015-ERC Start-
ing Grant, Project ID: 678082, “BRISC: Bounded Rationality in Sensorimotor Coordi-
nation”).
Appendix
7.1 Proof of (13)
The Free Energy functional Fthat is optimized in the Free Energy principle (12) is
given by
F[P1,...,P N] =
∑
x
p(x) F0,loc(x) ,
where x:= (x0,...,x N), and for all k∈{0,...,n }
p(x) =ρ(x0) P1
(
x1
⏐⏐x1
sel,x1
in
)
···PN
(
xN
⏐⏐xN
sel,xN
in
)
,
Fk,loc(x) =U(x0,xN) −
∑
i>k
1
βi
log Pi(xi|xi
sel,xi
in)
pi(xi|xi
sel) .
By writing
F0,loc(x) =Fk,loc(x) − 1
βk
log Pk(xk|xk
sel,xk
in)
pk(xk|xk
sel) −Rk(x<k) ,
where x<k := (x0,...,x k−1), and
Rk(x<k) :=
∑
i<k
1
βi
log Pi(xi|xi
sel,xi
in)
pi(xi|xi
sel) ,
30
we obtain for any k∈{0,...,n },
F[P1,...,P N] =
∑
xk
sel,xk
in
p(xk
sel,xk
in)
[∑
xk
Pk(xk|xk
sel,xk
in)
∑
˜xc
p(˜xc|˜x)Fk,loc(x)
− 1
βk
DKL
(
Pk(·|xk
sel,xk
in)
pk(xk|xk
sel)
)]
−
∑
x<k
p(x<k) Rk(x<k)
with ˜x = (xk,xk
sel,xk
in) and ˜xc := (x0,...,x N) \˜x. In this form, we can see that
optimizing for Pk yields the Boltzmann distribution (13) with respect to the effective
utility Fk(˜x) =∑
˜xc p(˜xc|˜x)Fk,loc(x) as deﬁned in (14).
References
Abreu, D. and Rubinstein, A. (1988). The structure of nash equilibrium in repeated
games with ﬁnite automata. Econometrica, 56(6):1259–1281.
Acerbi, L., Vijayakumar, S., and Wolpert, D. M. (2014). On the origins of suboptimality
in human probabilistic inference. PLOS Computational Biology, 10(6):1–23.
Arimoto, S. (1972). An algorithm for computing the capacity of arbitrary discrete
memoryless channels. IEEE Transactions on Information Theory, 18(1):14–20.
Aumann, R. J. (1997). Rationality and bounded rationality. Games and Economic
Behavior, 21(1):2 – 14.
Bishop, C. M. (2006). Pattern Recognition and Machine Learning (Information Science
and Statistics). Springer-Verlag New York, Inc., Secaucus, NJ, USA.
Blahut, R. E. (1972). Computation of channel capacity and rate-distortion functions.
IEEE Transactions on Information Theory, 18(4):460–473.
Burns, E., Ruml, W., and Do, M. B. (2013). Heuristic search when time matters.Journal
of Artiﬁcial Intelligence Research, 47(1):697–740.
Camacho, A. and Persky, J. J. (1988). The internal organization of complex teams:
Bounded rationality and the logic of hierarchies. Journal of Economic Behavior &
Organization, 9(4):367–380.
Chehouri, A., Younes, R., Perron, J., and Ilinca, A. (2016). A constraint-handling tech-
nique for genetic algorithms using a violation factor. Journal of Computer Sciences,
12(7):350–362.
Csisz´ar, I. and Tusn´ady, G. (1984). Information geometry and alternating minimization
procedures. Statistics and Decisions, Supplement Issue, 1:205–237.
DeCanio, S. J. and Watkins, W. E. (1998). Information processing and organizational
structure. Journal of Economic Behavior & Organization, 36(3):275–294.
31
Edward, V ., Noah, G., L., G. T., and B., T. J. (2014). One and done? optimal decisions
from very few samples. Cognitive Science, 38(4):599–637.
Friedman, N. and Koller, D. (2003). Being bayesian about network structure. a bayesian
approach to structure discovery in bayesian networks. Machine Learning, 50(1):95–
125.
Friston, K. J. (2009). The free-energy principle: a rough guide to the brain? Trends in
Cognitive Sciences, 13(7):293 – 301.
Friston, K. J. (2010). The free-energy principle: a uniﬁed brain theory? Nature Reviews
Neuroscience, 11.
Friston, K. J., Levin, M., Sengupta, B., and Pezzulo, G. (2015a). Knowing one’s place:
a free-energy approach to pattern regulation. Journal of The Royal Society Interface,
12(105).
Friston, K. J., Lin, M., Frith, C., and Pezzulo, G. (2017a). Active inference, curiosity
and insight. Neural Computation, 29(10):2633–2683.
Friston, K. J., Parr, T., and de Vries, B. (2017b). The graphical brain: Belief propagation
and active inference. Network Neuroscience, 1(4):381–414.
Friston, K. J., Rigoli, F., Ognibene, D., Mathys, C., Fitzgerald, T., and Pezzulo, G.
(2015b). Active inference and epistemic value. Cognitive Neuroscience, 6(4):187–
214. PMID: 25689102.
Geanakoplos, J. and Milgrom, P. (1991). A theory of hierarchies based on limited man-
agerial attention. Journal of the Japanese and International Economies , 5(3):205–
225.
Genewein, T. and Braun, D. A. (2013). Abstraction in decision-makers with limited
information processing capabilities. NIPS workshop on Planning with Information
Constraints.
Genewein, T., Leibfried, F., Grau-Moya, J., and Braun, D. A. (2015). Bounded ratio-
nality, abstraction, and hierarchical decision-making: An information-theoretic opti-
mality principle. Frontiers in Robotics and AI, 2:27.
Gershman, S. J., Horvitz, E. J., and Tenenbaum, J. B. (2015). Computational rationality:
A converging paradigm for intelligence in brains, minds, and machines. Science,
349(6245):273–278.
Gigerenzer, G. and Selten, R. (2001). Bounded Rationality: The Adaptive Toolbox .
MIT Press.
Graicunas, V . A. (1933). Relationship in organization. Bulletin of the International
Management Institute, (7):39–42.
Hern´andez, P. and Solan, E. (2016). Bounded computational capacity equilibrium.Jour-
nal of Economic Theory, 163:342 – 364.
32
Howes, A., Lewis, R. L., and Vera, A. (2009). Rational adaptation under task and pro-
cessing constraints: Implications for testing theories of cognition and action. Psy-
chological Review, 116(4):717–751.
Jain, P. and Kar, P. (2017). Non-convex Optimization for Machine Learning . Now
Foundations and Trends.
Jones, B. D. (2003). Bounded rationality and political science: Lessons from public
administration and public policy. Journal of Public Administration Research and
Theory: J-PART, 13(4):395–412.
Kaelbling, L. P., Littman, M. L., and Cassandra, A. R. (1998). Planning and acting in
partially observable stochastic domains. Artiﬁcial Intelligence, 101(1):99 – 134.
Kappen, H. J., G´omez, V ., and Opper, M. (2012). Optimal control as a graphical model
inference problem. Machine Learning, 87(2):159–182.
Kashtan, N. and Alon, U. (2005). Spontaneous evolution of modularity and network
motifs. Proceedings of the National Academy of Sciences, 102(39):13773–13778.
Knight, F. (1921). Risk, Uncertainty and Proﬁt. Cambridge, MA: Houghton Mifﬂin.
Lewis, R. L., Howes, A., and Singh, S. (2014). Computational rationality: Linking
mechanism and behavior through bounded utility maximization. Topics in Cognitive
Science, 6(2):279–311.
Lipman, B. L. (1995). Information processing and bounded rationality: A survey. The
Canadian Journal of Economics / Revue canadienne d’Economique, 28(1):42–67.
Marschak, T. and Reichelstein, S. (1998). Network mechanisms, informational efﬁ-
ciency, and hierarchies. Journal of Economic Theory, 79(1):106 – 141.
Mattsson, L.-G. and Weibull, J. W. (2002). Probabilistic choice and procedurally
bounded rationality. Games and Economic Behavior, 41(1):61 – 78.
McKelvey, R. D. and Palfrey, T. R. (1995). Quantal response equilibria for normal form
games. Games and Economic Behavior, 10(1):6 – 38.
M´ezard, M. and Montanari, A. (2009). Information, Physics, and Computation. Oxford
Graduate Texts.
Neyman, A. (1985). Bounded complexity justiﬁes cooperation in the ﬁnitely repeated
prisoners’ dilemma. Economics Letters, 19(3):227 – 229.
Ochs, J. (1995). Games with unique, mixed strategy equilibria: An experimental study.
Games and Economic Behavior, 10(1):202–217.
Ortega, P. A. and Braun, D. A. (2010). A conversion between utility and information.
The Third Conference on Artiﬁcial General Intelligence, pages 115–120.
33
Ortega, P. A. and Braun, D. A. (2011). Information, Utility and Bounded Rationality ,
pages 269–274. Springer Berlin Heidelberg, Berlin, Heidelberg.
Ortega, P. A. and Braun, D. A. (2013). Thermodynamics as a theory of decision-making
with information-processing costs. Proceedings of the Royal Society of London A:
Mathematical, Physical and Engineering Sciences, 469(2153).
Ortega, P. A. and Braun, D. A. (2015). What is epistemic value in free energy models
of learning and acting? a bounded rationality perspective. Cognitive Neuroscience,
6(4):215–216. PMID: 25990838.
Radner, R. (1993). The organization of decentralized information processing. Econo-
metrica, 61(5):1109–1146.
Russell, S. J. and Subramanian, D. (1995). Provably bounded-optimal agents. Journal
of Artiﬁcial Intelligence Research, 2(1):575–609.
Shannon, C. E. (1959). Coding theorems for a discrete source with a ﬁdelity criterion.
IRE International Convention Record, 7:142–163.
Simon, H. A. (1943). A Theory Of Administrative Decision. PhD thesis, University of
Chicago.
Simon, H. A. (1955). A behavioral model of rational choice. The Quarterly Journal of
Economics, 69(1):99–118.
Simon, H. A. (1979). Rational decision making in business organizations. The Ameri-
can Economic Review, 69(4):493–513.
Sims, C. A. (2003). Implications of rational inattention. Journal of Monetary Eco-
nomics, 50(3):665 – 690. Swiss National Bank/Study Center Gerzensee Conference
on Monetary Policy under Incomplete Information.
Spiegler, R. (2011). Bounded Rationality and Industrial Organization. Oxford Univer-
sity Press: Oxford.
Still, S. (2009). Information-theoretic approach to interactive learning. EPL (Euro-
physics Letters), 85(2):28005.
Tishby, N., Pereira, F. C., and Bialek, W. (1999). The information bottleneck method.
pages 368–377.
Tishby, N. and Polani, D. (2011). Information theory of decisions and actions. In
Perception-Action Cycle: Models, Architectures, and Hardware. Springer.
Todorov, E. (2009). Efﬁcient computation of optimal actions. Proceedings of the Na-
tional Academy of Sciences, 106(28):11478–11483.
von Neumann, J. and Morgenstern, O. (1944). Theory of Games and Economic Behav-
ior. Princeton University Press.
34
Wagner, G. P., Pavlicev, M., and Cheverud, J. M. (2007). The road to modularity.Nature
Reviews Genetics, 8:921.
Wolpert, D. H. (2006). Information Theory – The Bridge Connecting Bounded Rational
Game Theory and Statistical Physics , pages 262–290. Springer Berlin Heidelberg,
Berlin, Heidelberg.
Yedidia, J. S., Freeman, W. T., and Weiss, Y . (2005). Constructing free-energy ap-
proximations and generalized belief propagation algorithms. IEEE Transactions on
Information Theory, 51(7):2282–2312.
35