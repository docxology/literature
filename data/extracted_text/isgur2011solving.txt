arXiv:1105.2351v2  [math.CO]  26 Jun 2011
SOL VING NON-HOMOGENEOUS NESTED RECURSIONS USING
TREES
ABRAHAM ISGUR, MUSTAZEE RAHMAN, AND STEPHEN TANNY
Abstract. The solutions to certain nested recursions, such as Conolly ’s C(n) = C(n −
C(n − 1)) + C(n − 1 − C(n − 2)), with initial conditions C(1) = 1 , C (2) = 2, have
a well-established combinatorial interpretation in terms of counting leaves in an inﬁnite
binary tree. This tree-based interpretation, which has a na tural generalization to a k-term
nested recursion of this type, only applies to homogeneous r ecursions, and only solves each
recursion for one set of initial conditions determined by th e tree. In this paper, we extend
the tree-based interpretation to solve a non-homogeneous v ersion of the k-term recursion
that includes a constant term. To do so we introduce a tree-gr afting methodology that
inserts copies of a ﬁnite tree into the inﬁnite k-ary tree associated with the solution of the
corresponding homogeneous k-term recursion. This technique can also be used to solve
the given non-homogeneous recursion with various sets of in itial conditions.
1. Introduction
In this paper all values for the variables and parameters are integers unless otherwise
speciﬁed. For k ≥ 1, ai, and bi > 0, i = 1 . . . k , consider the nested (also called meta-
Fibonacci) homogeneous recursion
A(n) =
k∑
i=1
A(n − ai − A(n − bi)) (1.1)
which we abbreviate as ⟨a1; b1 : · · · : ak; bk⟩. We call the sequences that appear as solutions
to nested recursions meta-Fibonacci sequences.
Over the past twenty years, many special cases of (1.1), toge ther with alternative sets of
initial conditions, have been examined (see the references for speciﬁcs). Examples include
Hofstadter’s famous and mysterious Q-sequence [6] given by ⟨0; 1 : 0; 2 ⟩ with Q(1) = Q(2) =
1, and Conolly’s well-known sequence C(n) [4] given by ⟨0; 1 : 1; 2 ⟩ with C(1) = 1 , C(2) =
2. Recently, fascinating and unexpected combinatorial con nections have been discovered
between the solutions to certain such nested recursions and inﬁnite, labeled trees [2, 9, 8, 7].
For example, it is shown in [8] that the shifted Conolly seque nce Cs(n) determined by
⟨s; 1 : s + 1; 2 ⟩ for any ﬁxed s ≥ 0 and initial conditions Cs(i) = 1 for 1 ≤ i ≤ s + 1 and
Cs(s + 2) = 2 counts the number of leaves in a suitably constructed i nﬁnite labeled binary
tree (with root at inﬁnity) that have labels that are less tha n or equal to n (the construction
depends on the parameter s). In the labeling, each node of the inﬁnite binary tree recei ves
one label except for the so-called s-nodes along the top of the tree, each of which receives
s labels. In [9] an analogous combinatorial interpretation i s derived for solutions to the
k-term recursion (1.1) with ai = s + i − 1 and bi = i, and with k + s initial conditions
that are determined by the leaf counts of the correspondingl y constructed inﬁnite, labeled
Date: September 25, 2018.
2000 Mathematics Subject Classiﬁcation. Primary 05A19, 11B37; Secondary 05A15, 05C05.
Key words and phrases. Non-homogeneous nested recursion, meta-Fibonacci sequen ce, Conolly sequence.
1
2 ABRAHAM ISGUR, MUSTAZEE RAHMAN, AND STEPHEN TANNY
k-ary tree. These initial conditions are said to “follow the t ree”, in the sense that they are
precisely the ones that force the solution to conform to the s peciﬁed labeled tree.
Building on this work, Isgur et al [7] vary the labeling schem e by inserting j labels in
each node of the k-ary tree rather than a single label, where j ≥ 1 is a ﬁxed parameter.
In this way they derive a combinatorial interpretation for t he solution to the generalized
Conolly recurrence
R(n) =
k∑
i=1
R(n − s − (i − 1)j − R(n − ij)) (1.2)
with the initial conditions: R(i) = i for 1 ≤ i ≤ j, R(i) = j for j +1 ≤ i ≤ j +s, R(i) = i−s
for j + s + 1 ≤ i ≤ kj + s, and R(i) = kj for kj + s + 1 ≤ i ≤ (k + 1)j + 2s. It is shown
that R(n) counts the number of labels in the leaves of the labeled k-ary tree that are less
than or equal to n.
Here we extend the tree-based correspondence described abo ve to combinatorially inter-
pret solutions to a non-homogeneous version of the Conolly n ested recursion (1.2), namely,
R(n) =
k∑
i=1
R(n − s − (i − 1)j − R(n − ij)) + ν (1.3)
where ν is any constant, and with speciﬁed initial conditions. Inte rest in such nested
recursions is natural and longstanding; see, for example, [ 5], where the recursion g(n) =
g(n − g(n − 1)) + 1, with g(1) = 1, is shown to have a neat, closed form solution. Our
focus on a constant for the non-homogeneous term in (1.3) can be readily explained: if the
non-homogeneous term is an integer valued function ν(n) with |ν(n)| ≥ cn for all n, then
the right side of (1.3) grows at least linearly in n. Therefore R(n) will grow at least linearly
in n and it seems plausible that eventually one of the arguments n − s − (i − 1)j − R(n − ij)
in (1.3) will be negative or will exceed n. At that point the recursion will cease to be
well-deﬁned. So a constant value for ν(n) is a natural choice. 1
To solve (1.3) combinatorially we “graft” inﬁnitely many co pies of a ﬁnite, rooted tree
T (or in some cases a portion of T ) onto the original k-ary tree that solves the related
homogeneous recursion (1.2). As we explain below, it turns o ut that for any given value of
ν in (1.3), we can ﬁnd inﬁnitely many ﬁnite trees T that correspond to that choice of ν.
Each of these ﬁnite trees determines a set of initial conditi ons for the recursion, and these
sets of initial conditions may diﬀer. Thus, our tree grafting technique permits us to ﬁnd
combinatorial interpretations for diﬀerent sets of initial conditions for the same recursion.
In particular, we can use our technique for the case ν = 0, thereby solving the homogeneous
nested recursion (1.2) with initial conditions determined by the choice of T . Prior to this,
the only combinatorial solution to (1.2) is the one associat ed with the initial conditions
imposed by the leaf counts of the usual k-ary tree [9, 7].
The outline of the rest of this paper is as follows. In Section 2 we describe precisely the
procedure for grafting copies of an arbitrary ﬁnite, rooted tree T on the inﬁnite k-ary tree
in [9, 7], and for labeling the resulting inﬁnite tree K. This construction depends upon T ,
as well as the three parameters k, j and s in (1.3). In Section 3 we establish that the inﬁnite
tree K constructed in Section 2 provides a combinatorial interpre tation to (1.3): R(n) is
the number of labels up to n on leaves of K. Finally, in Section 4 we discuss alternative
1Of course, one could consider non-constant, sub-linear ν(n). To date our empirical investigations suggest
that only constant ν(n) lead to well-deﬁned, inﬁnite solution sequences. Conside rable further work is needed
in this area to conﬁrm this contention, or to determine which non-constant ν(n), if any, lead to an inﬁnite
solution sequence to (1.3) for some set of initial condition s.
SOL VING NON-HOMOGENEOUS NESTED RECURSIONS USING TREES 3
labeling schemes for K that give rise to a variety of interesting results; in partic ular, we
derive a new combinatorial interpretation for Golomb’s rec ursive sequence g(n).
2. Constructing the infinite treeK: the grafting technique
Let T be any ﬁnite rooted tree with at least two nodes. The height p of T is the length
of the longest path from the root to any of its nodes. Fix k ≥ 1 corresponding to the
desired value of k in (1.3). We create a modiﬁed labeled k-ary tree K using T .
The construction of K requires two steps. First we construct the nodes and edges, t hat
is, the skeleton, of K; this involves grafting copies of T on the inﬁnite k-ary tree in [9, 7].
Then we insert labels, which are successive positive intege rs, within the nodes of K. To do
this, ﬁrst we specify the order in which the nodes of K are to be traversed one at a time;
then we insert the appropriate number of labels, either j or s (the parameters in (1.3)) in
each node. As we traverse K, we keep count of the number of labels up to that point that
are located in the leaves of K. The “leaf label” sequence generated by this enumeration
satisﬁes a nested, non-homogeneous Conolly-type recursio n of the form (1.3), where the
tree T determines ν.
To help describe this construction, we illustrate our discu ssion using the rooted tree T
of height 3 in Figure 2.1, together with k = 2. We show how this results in an inﬁnite,
labeled binary tree with leaf label counting function R(n) that satisﬁes the recursion R(n) =
R(n − R(n − 2)) + R(n − 2 − R(n − 4)) − 2.
Root 
Figure 2.1. Example of a rooted tree T of height p = 3.
Constructing the skeleton ofK. The skeleton of K consists of an inﬁnite sequence Ki
of rooted, ﬁnite subtrees of K that we join together to form K. For each i, the root of Ki
is called the ith supernode of K, while all other nodes are regular nodes. For i = p > 1,
where p is the height of T , the subtree Kp is isomorphic to T . The subtree Kp−1 is obtained
by making a copy of Kp and then deleting all the leaves of the copy. See Figure 2.2, w here
we illustrate the subtrees K3 and K2 using the tree T of height p = 3 in Figure 2.1; we
draw the supernodes as squares and the regular nodes as circl es. For 2 < i ≤ p, we repeat
this process successively, making Ki−1 by copying Ki and deleting the leaves of the copy.
The subtree K1 is a special case: after deleting the leaves of a copy of K2, we attach an
extra regular node as a child of the ﬁrst supernode (this extr a child can be considered as
the zeroth supernode - see Section 4).
For i > p we construct the subtrees Ki by ﬁrst making a copy of Ki−1 and then attaching
precisely k nodes to each of its leaves. Thus, for i > p the subtree Ki consists of the tree
T with each of its leaves the root of a k-ary subtree of height i − p, so Ki has height i.
Finally, for all i > 0 we connect all the subtrees Ki to Ki+1 by adding an edge from the
4 ABRAHAM ISGUR, MUSTAZEE RAHMAN, AND STEPHEN TANNY
ith supernode to the ( i + 1)st. See Figure 2.2. Notice that the tree K is closely related to
the inﬁnite k-ary tree in [9, 7]: take the former k-ary tree, insert the ﬁnite tree T (or a
portion of it), with the root of T coinciding with each of the supernodes of the k-ary tree,
and leave the rest of the original k-ary tree untouched.
Binary tree structure after initial 
segment of each subtree hereafter. 
Figure 2.2. First 5 subtrees of the skeleton of K derived from the tree in
Figure 2.1, using k = 2.
Labeling K. Fix the values j ≥ 1 and s ≥ 0, corresponding to the parameters of the
same name in (1.3). Insert j labels into each regular node of K and s labels into each
supernode; for convenience, we refer to the regular nodes an d supernodes as j-nodes and
s-nodes, respectively. The labels consist of successive int egers starting at 1. Before we can
insert these labels we must specify the traversal order of th e nodes in K. We recursively
deﬁne a pre-order traversal as follows: K1 is traversed by beginning at the ﬁrst child of
the ﬁrst supernode followed by the supernode itself and then its remaining children (note
this is not the pre-order traversal of K1). Having traversed Ki for i ≥ 1, the subtree Ki+1
is traversed next in the usual pre-order way by beginning at i ts root, which is the ( i + 1)th
supernode. See Figure 2.3, where we label the nodes of K in the order in which they are
traversed, and then Figure 2.4, where we insert j = 2 labels in each regular node and s = 0
labels in each supernode.
We explain in the next section how the combinatorial interpr etation for the solution
of (1.3) is derived from the “leaf label” sequence generated from K. Before doing so, we
require additional terminology and notation with which we c onclude this section.
Call K(n) the subtree of K containing all the labels between 1 and n and all the nodes
in pre-order up to the node containing n. For m ≥ 1, deﬁne m to be a leaf label of K if
m is contained in a leaf of K. Throughout the paper the leaf labels of K(n) are deﬁned
to be all the labels in K(n) that are leaf labels in K. It is very important to note that a
node may be a leaf in K(n) and not be a leaf in K. For example, in Figure 2.4, the node
containing the label 21 is a leaf of K(21) but not of K. Thus, 21 is not a leaf label.
Let R(n) be the number of leaf labels in K(n). In Figure 2.4, R(7) = 5 and R(20) = 10.
A penultimate node of K is a non-leaf node in K such that all of its children are leaves
(for example, nodes 2 and 18 in Figure 2.3 but not node 7). Call the labels in a penultimate
SOL VING NON-HOMOGENEOUS NESTED RECURSIONS USING TREES 5
2
1 3
4
12 
21 
26 27 29 30 
8
9
7
10 11 
5
6 16 17 
15 
13 
14 
19 20 
18 25 28 
24 
22 
23 
32 35 
31 
33 34 36 37 
Figure 2.3. The order in which the nodes of K from Figure 2.2 are traversed.
1,2 3,4 41,42 43,44 47,48 49,50 
9,10 
11,12 
13,14 15,16 
5,6 
7,8 23,24 25,26 
21,22 
17,18 
19,20 
29,30 31,32 
27,28 39,40 45,46 
37,38 
33,34 
35,36 
53,54 59,60 
51,52 
55,56 57,58 61,62 63,64 
Figure 2.4. First 5 subtrees of the completed inﬁnite tree K from our
example. The labeling parameters are j = 2 and s = 0.
node penultimate labels. The penultimate nodes (respectively, labels) of K(n) are the
penultimate nodes (respectively, labels) of K that are included in K(n).
Note that for i ≥ 2 the leaves of Ki are the penultimate nodes of Ki+1; the leaves of K1,
other than the ﬁrst leaf, are the penultimate nodes of K2, and K1 always has exactly one
penultimate node (the ﬁrst s-node of K). Let ℓi be the number of leaves in Ki. Deﬁne α
(respectively, β) as the number of leaf labels (respectively, penultimate la bels) occurring in
K1 through Kp. Then by the preceding observation α = j ∑ p
i=1 ℓi, and β = j(∑ p−1
i=1 ℓi −
1) + s. Finally, let N(i) be the largest label of K that occurs in Ki.
We are now prepared to state and prove our key ﬁnding.
3. Solving the non-homogeneous Conolly nested recursion
Theorem 3.1. Let T be a ﬁnite rooted tree of height p. Let K be the inﬁnite tree constructed
using T and ﬁxed parameters k ≥ 1, j ≥ 1, and s ≥ 0. Deﬁne ν = α − k(β − s + j). Let
R(n) be the leaf label counting function of K. Then for n > N (p + 1), R(n) satisﬁes the
6 ABRAHAM ISGUR, MUSTAZEE RAHMAN, AND STEPHEN TANNY
non-homogeneous nested recursion (1.3), that is,
R(n) =
k∑
i=1
R(n − s − (i − 1)j − R(n − ij)) + ν .
Equivalently, if any function L(n) is deﬁned by (1.3) and the ﬁrst N(p + 1) values of
L(n) agree with the corresponding values for the leaf label count ing function R(n), then
L(n) = R(n) for all n.
In Figure 2.4 p = 3 , k = j = 2 , s = 0 and ν = 10 − 2(4 − 0 + 2) = −2. Then for
n > N (4) = 32, the leaf label counting function R(n) satisﬁes R(n) = R(n − R(n − 2)) +
R(n − 2 − R(n − 4)) − 2.
Before turning to the proof of Theorem 3.1, we provide severa l observations. From the
formulas for α and β in Section 2 we have a computationally simpler expression fo r ν:
ν = jℓp − j(k − 1)(ℓ1 + · · · + ℓp−1) if p ≥ 2, and ν = j(ℓ1 − k) if p = 1 .
In some cases fewer than N(p + 1) initial conditions will suﬃce. For our purposes, we
are only interested in knowing that for some suﬃciently larg e number of initial conditions
the recursion (1.3) will generate the leaf label counting se quence as its solution. Finally,
note that diﬀerent choices of T enable us to solve recursions of the form (1.3) with diverse
initial conditions. In particular, now we are able to solve ( 1.2) with many diﬀerent sets of
initial conditions.
We begin the proof of Theorem 3.1 by deﬁning the pruning operation on the subtree
K(n) for n > N (1). This operation yields a new tree PK(n) deﬁned as follows: ﬁrst, delete
all leaf labels of K(n) along with the nodes containing them. Then convert the ﬁrst s-node
into a j-node. Finally, relabel the new tree in pre-order, keeping i n mind that the ﬁrst
s-node is now a j-node so it receives j labels rather than s. See Figure 3.1 for the pruning
of K(27) from the tree in Figure 2.4. Note that the node of K(27) that contains the label
27 is a leaf of K(27) but not of K, and as such it is not deleted.
The signiﬁcance of the pruning operation on the subtree K(n) is that it results in K(m)
for some m < n . In this regard, we can view K as self-similar with respect to the pruning
operation. Let PR(n) denote the number of leaf labels in PK(n). We build to the proof of
Theorem 3.1 via a series of lemmas concerning PK(n).
Lemma 3.2 (Pruning). For n > N (1) the tree PK(n) has n − s + j − R(n) labels and is
isomorphic to the subtree K(n − s + j − R(n)). Consequently, PR(n) = R(n − s + j − R(n)).
Proof. Since K(n) contains R(n) leaf labels, deleting the leaf labels of K(n) results in a loss
of R(n) labels. Also, replacing the ﬁrst s-node with a j-node results in a net change of
j − s labels following the pruning operation. Thus, the total num ber of labels in PK(n) is
n − R(n) − s + j.
That PK(n) is isomorphic to the subtree K(n − s + j − R(n)) follows directly from the
deﬁnition of the pruning operation and the construction of t he tree K, since deleting all the
leaves of Kq results in Kq−1. More generally, if we delete the leaves of K from the subtree
of Kq that consists of the ﬁrst m nodes of Kq (in pre-order), and then relabel in pre-order,
the result is the subtree consisting of the ﬁrst m′ nodes of Kq−1 for some m′ < m .
Finally, since PK(n) is isomorphic to K(n − s + j − R(n)) and K(n − s + j − R(n))
contains R(n − s + j − R(n)) leaf labels by deﬁnition, PR(n) = R(n − s + j − R(n)). □
The key to the proof of Theorem 3.1 is that since most penultim ate nodes have k children,
k times the number of penultimate labels in K(n) is essentially the number of leaf labels in
SOL VING NON-HOMOGENEOUS NESTED RECURSIONS USING TREES 7
1,2 3,4 
9,10 
11,12 
13,14 15,16 
5,6 
7,8 23,24 25,26 
21,22 
17,18 
19,20 
27 
1,2 3,4 
9,10 
11,12 
13,14 15,16 
5,6 
7,8 23,24 25,26 
21,22 
17,18 
19,20 
27 
9,10 
11,12 21,22 
17,18 
19,20 
27 . , . 5,6 
5,6 
7,8 13,14 
9,10 
11,12 
15 1,2 3,4 
Deletion of the 
leaves of K 
Conversion of 
ﬁrst s-node 
into a j-node 
Pre-order relabeling 
Not a 
leaf of K 
Figure 3.1. The pruning operation on K(27) results in K(15).
K(n), with the diﬀerence being given by the non-homogeneous term ν. Call K(n) complete
if each of its penultimate nodes has all of its children from K, and each of these children
has j labels. If K(n) is complete then the number leaf labels in PK(n) is j times the the
number of penultimate level nodes in K(n).
Lemma 3.3 (Completeness). For n ≥ N(p), if K(n) is complete then
PR(n) = R(n) − ν
k .
Proof. Recall that α (respectively, β) is the number of leaf labels (respectively, penultimate
labels) occurring in K1 through Kp. Since n ≥ N(p), the pruned tree PK(n) contains the
subtrees K1 to Kp−1, so has β − s + j leaf labels in these subtrees. So PR(n) − (β − s + j)
is the number of leaf labels in PK(n) occurring after Kp−1. But by the self-similarity of K
with respect to pruning, this is also the number of penultima te labels in K(n) after label
N(p), so after Kp.
By the completeness of K(n), each penultimate node of K(n) occurring after Kp has k
children, these children are the only leaves of K included in K(n) that occur after Kp, and
all these children, as well as their penultimate node parent s, have j labels each. Group
these children with their penultimate level parents (who al so come after Kp). We then get
a k : 1 correspondence between these children and their parents , which also extends to a
correspondence between the labels situated in them.
Now, R(n) − α counts the number of leaf labels in K(n) after label N(p). So it equals
the number of labels in the children mentioned in the precedi ng paragraph. On the other
hand PR(n) − (β − s + j), the number of penultimate labels in K(n) after label N(p), is the
number of labels in the parents mentioned above. Thus, we use the correspondence above
to count the number of leaf labels in K(n) after label N(p) in two ways:
k(PR(n) − (β − s + j)) = R(n) − α .
8 ABRAHAM ISGUR, MUSTAZEE RAHMAN, AND STEPHEN TANNY
Simplifying and substituting ν = α − k(β − s + j) we get the desired result. Note that this
also explains the deﬁnition of ν. □
Now observe that if K(n) and K(m) have the same penultimate labels, then PR(n) =
PR(m). We use this to compute the values of PR(n) based on the location of n in K.
To this end, let ∆( n) denote the minimal non-negative integer such that K(n + ∆( n)) is
complete.
Lemma 3.4. The following holds for n > N (p + 1).
(1) If n is neither a leaf label nor a penultimate label then K(n) is complete. Conse-
quently for every n > N (p + 1), we have that 0 ≤ ∆( n) < (k + 1)j.
(2) Suppose ∆( n) > 0 so that K(n) is not complete. Then 0 < ∆( n) < kj if and only
if n is a leaf label, and ∆( n) ≥ kj if and only if n is a penultimate label.
(3) If 0 ≤ ∆( n) ≤ kj then PR(n) = R(n) + ∆( n) − ν
k .
(4) If ∆( n) > kj then PR(n) = R(n) + kj − ν
k − ∆( n) + kj.
Proof. (1) and (2): The ﬁrst statement in (1) follows from the deﬁnit ion of completeness
and the construction of K. To prove the second part of (1) and assertion (2), note that i f
∆( n) > 0 then n is a label on either a penultimate node or on one of the k children of a
penultimate node. In either case we can complete K(n) by adding any missing labels on
the penultimate node, and nodes and labels for any missing ch ildren until the last label in
the last child of said penultimate node. In either case we add up to (but excluding) ( k +1)j
labels. This proves the second statement in (1). Further, th e label n is on a penultimate
node if and only if kj ≤ ∆( n) < (k + 1)j (since in this case we must add the nodes and
labels for all k children); otherwise, n is a label in some child on the bottom level, and
0 ≤ ∆( n) ≤ kj. This establishes (2).
(3): If ∆( n) = 0 then this assertion is simply Completeness Lemma 3.3. If 0 < ∆( n) ≤ kj
then from (2) we get that there exists a penultimate node X such that either n is a label in
one of its k children (when 0 < ∆( n) < kj ) or n is the ﬁnal label (in pre-order) of X (when
∆( n) = kj). In both cases all of the trees K(n), . . . , K (n+∆( n)) have the same penultimate
labels, namely, all the penultimate labels from 1 through to the ﬁnal label in X. It follows,
as we observed just prior to the statement of this lemma, that PR(n) = PR(n + ∆( n)).
Further, R(n + ∆( n)) = R(n) + ∆( n), since the ∆( n) labels following n are all leaf labels in
K. Since K(n + ∆( n)) is complete, we apply the Completeness Lemma 3.3 to it to de duce
that
PR(n) = PR(n + ∆( n)) = R(n + ∆( n)) − ν
k = R(n) + ∆( n) − ν
k .
(4): If ∆( n) > kj then using the same notation as in the previous paragraph we s ee from
(2) that n is a label of the penultimate node X but it is not the last label of X. Let n′ be the
last label of X so n′ −n = ∆( n)−kj. Also PR(n′) = PR(n)+( n′ −n) = PR(n)+∆( n)−kj,
SOL VING NON-HOMOGENEOUS NESTED RECURSIONS USING TREES 9
and clearly R(n) = R(n′) and ∆( n′) = kj. It follows by (3), applied to n′, that
PR(n) = PR(n′) − ∆( n) + kj
= R(n′) + ∆( n′) − ν
k − ∆( n) + kj
= R(n′) + kj − ν
k − ∆( n) + kj .
This proves (4) and completes the proof of the lemma. □
To prove Theorem 3.1 we demonstrate the following key relati on: for n > N (p + 1),
R(n) − ν =
k∑
i=1
PR(n − ij) . (3.1)
From (3.1) and the Pruning Lemma 3.2 our desired result is imm ediate, since for n >
N(p + 1),
R(n) =
k∑
i=1
PR(n − ij) + ν
=
k∑
i=1
R(n − s − (i − 1)j − R(n − ij)) + ν .
To prove relation (3.1) we have two cases.
Case 1: Suppose n is a leaf label. Then there exists q and r such that 1 ≤ q ≤ k and
1 ≤ r ≤ j and n is the rth smallest label on the qth child (in pre-order) of its parent
node X (a penultimate node). The trees K(n), K(n − j), . . . , K(n − (q − 1)j) all have the
same penultimate labels consisting of all such labels up to a nd including the penultimate
labels in X. The tree K(n − qj) ends on the rth label in X, so its penultimate labels diﬀer
from those of the previously mentioned trees only at the last j − r labels of X. The trees
K(n − (q + 1)j), . . . , K(n − kj) do not end on penultimate nodes, so they all have the same
penultimate labels, namely, all penultimate labels occurr ing before the labels in X.
We now apply the remark we made just prior to Lemma 3.4 that if t wo trees have
the same penultimate labels, their pruned trees have the sam e number of leaf labels. So
PR(n) = PR(n − ij) for 1 ≤ i ≤ q − 1. In the same way, PR(n − qj) = PR(n) − (j − r)
and PR(n − ij) = PR(n) − j for q + 1 ≤ i ≤ k. But ∆( n) = ( j − r) + j(k − q), so by (3) of
Lemma 3.4 we get PR(n) = R(n)+(j−r)+j(k−q)−ν
k . Thus we conclude that
k∑
i=1
PR(n − ij) = kPR(n) − (j − r) − j(k − q) = R(n) − ν .
Case 2: Suppose n is not a leaf label. In this case the subtrees K(n − j), . . . , K(n − kj) all
have the same penultimate labels, so PR(n − j) = PR(n − ij) for 1 ≤ i ≤ k. The subtrees
K(n) and K(n − j) may diﬀer on at most one penultimate node, which happens prec isely
when n lies on a penultimate node X. So we can write PR(n − j) = PR(n) − r′ where
0 ≤ r′ ≤ j. Here r′ = 0 if and only if K(n) is complete, and otherwise n is the r′-th smallest
label on the penultimate node X.
If r′ = 0 then PR(n) = R(n)−ν
k by the Completeness Lemma 3.3. If r′ > 0 then ∆( n) =
kj + (j − r), and (4) of Lemma 3.4 implies that PR(n) = R(n)−ν
k + r′ after simpliﬁcation.
10 ABRAHAM ISGUR, MUSTAZEE RAHMAN, AND STEPHEN TANNY
Therefore in all cases we conclude that
k∑
i=1
PR(n − ij) = kPR(n − j) = k(PR(n) − r′)
= k
( R(n) − ν
k + r′ − r′
)
= R(n) − ν .
This completes the proof of Case 2, and the theorem.
4. Further applications
In the construction of the tree K, we created each subtree Ki by starting with a complete
k-ary tree of height i and inserting an arbitrary tree T . Here we describe how slight
modiﬁcations to this construction, such as to the labeling s cheme or to the number of
labels in various nodes, can still yield a tree K whose leaf label counting function satisﬁes
a recursion with the form (1.3). The key requirement to these modiﬁcations is that they
preserve the self-similarity of K with respect to a suitably adapted pruning operation (or
in other words, provided that removing the leaves of K results in a tree isomorphic to K
up to some consistent ﬁnite correction).
In what follows, instead of stating a complicated theorem de scribing the most general
possible modiﬁcation that we can devise, we illustrate the ﬂ exibility of our methodology
and its ability to produce interesting results via several e xamples.
Example 1 (Solving (1.3) with arbitrary values of s). We begin by describing how to
adjust the labeling of K to yield a combinatorial interpretation for solutions to (1 .3) with
arbitrary values for the parameter s. Our approach turns out to be somewhat simpler
than that of [9], where this is accomplished for (1.2), the ho mogeneous version of (1.3), by
removing labels from speciﬁc nodes in the tree when s < 0.
We change the number of labels inserted within each supernod e of K: let the mth su-
pernode receive sm ≥ 0 labels. Next, let the extra child of the ﬁrst supernode rece ive s0 ≥ 0
labels (instead of j). We now derive the resulting recursion related to K. To do so, we
must identify the nature of the pruning operation associate d with K.
For any label n, suppose that n lies in the subtree Km of K, where m = m(n). Prune
the subtree K(n) as follows: delete all the leaf labels and the nodes contain ing them.
Replace the si labels in the ith supernode by si−1 labels for each 1 ≤ i ≤ m. Then
relabel the new tree PK(n) in the usual way by pre-order. The tree PK(n) contains
n − R(n) + ( s0 − s1) + · · · + (sm − sm−1) = n − R(n) + s0 − sm labels, and it is isomorphic
to the subtree K(n − R(n) + s0 − sm). Analogous to the Pruning Lemma 3.2, we have that
PR(n) = R(n − R(n) + s0 − sm).
Similarly, we have the analogue of the Completeness Lemma 3. 3 with the new value of
ν = α − k(β + s0 − s1) (where α and β retain the same meaning as before). In the same
way, Lemma 3.4 and the key relation (3.1) continue to hold as b efore. Thus, we conclude
that the leaf label counting function R(n) satisﬁes
R(n) =
k∑
i=1
R(n − (sm(n−ij) − s0) − ij − R(n − ij)) + ν for n > N (p + 1) . (4.1)
SOL VING NON-HOMOGENEOUS NESTED RECURSIONS USING TREES 11
Notice that as i ranges from 1 to k, m(n − ij) can only take the values m(n) − 1 or m(n),
since jumping back by ij labels for 1 ≤ i ≤ k takes us at worst to the previous subtree
Km(n)−1.
When s0 = t + j and sm = s for all m ≥ 1 then sm(n − ij) = s for all n > N (p + 1), and
we deduce after some simpliﬁcation that
R(n) =
k∑
i=1
R(n − (s − t) − (i − 1)j − R(n − ij)) + ν (4.2)
for n > N (p + 1). The parameter s − t can take any integer value, whereas the equivalent
parameter s in (1.3) had to be nonnegative.
For the next application of our methodology, we apply the ide a in Example 1, together
with a modiﬁed labeling scheme, to solve (1.2) with speciﬁed initial conditions. We illustrate
our approach with k = 2, so with the recursion
R(n) = R(n − s − R(n − j)) + R(n − s − j − R(n − 2j)) . (4.3)
As we discussed in Section 1, this recursion, together with i nitial conditions that follow the
corresponding labeled binary tree, is solved in [7].
Example 2 (Solving (4.3) with more general initial conditions) . We demonstrate how to
solve (4.3) with initial conditions that begin with a string of s1 + 1 1s for any given s1 ≥ 0.
These are followed by an additional s + 5j − 1 initial values determined by the tree K that
we now construct.
Figure 4.1. The binary tree with label counts satisfying (4.3) and initi al
conditions beginning with s1 + 1 1s. The entries in each node indicate the
number of labels. We require j1 = 2 j − 1, j2 = j, and s2 = s.
Here K is the inﬁnite binary tree in [8] and T is K2 (see Figure 4.1). We traverse K in
the usual way. We label K as follows: insert s1 labels in the ﬁrst supernode, and s2 labels
in all the other supernodes. Insert one label in the left chil d of the ﬁrst supernode and
j1 labels in the right child of this supernode. The unique child of every other supernode
contains j2 labels. All other nodes in the tree get j labels (see Figure 4.1).
Now we determine values for the parameters j1, j2 and s2 so that the leaf label counting
function for K satisﬁes (4.3). By pruning the subtree K(n) of K we mean deleting all the
leaf labels of K(n) along with the nodes containing them, replacing the ﬁrst su pernode
with a regular node containing 1 label, replacing the s2 labels in second supernode with s1
labels, and replacing the j2 labels inside the child of the second supernode with j1 labels.
The resulting pruned tree is isomorphic to K(n − R(n) + 1 − s2 + j1 − j2), and so it contains
PR(n) = R(n − (s2 − 1 + j2 − j1) − R(n)) leaf labels.
12 ABRAHAM ISGUR, MUSTAZEE RAHMAN, AND STEPHEN TANNY
Once again we have the key relation R(n) = PR(n − j) + PR(n − 2j) + ν where ν =
α − 2(β − s1 + 1 − j2 + j1) = 2 j − j1 − 1. The term ν is the diﬀerence between the
number of leaf labels in K1 and K2 and twice the number of leaf labels in them after
they have been pruned. Since the non-homogeneous term in (4. 3) is 0 we must have
j1 = 2 j − 1 for ν to be 0. Furthermore, in order for PR(n − j) = R(n − s − R(n − j))
and PR(n − 2j) = R(n − s − j − R(n − 2j)) we require that s = j + s2 − 1 + j2 − j1,
which simpliﬁes to s2 + j2 = s + j. Thus, we may take s2 = s and j2 = j. Then for all
n > 5j + s + s1, the leaf label counting function R(n) satisﬁes (4.3), and R(n) begins with
s1 + 1 1s.
It is worth emphasizing that the tree-based solutions we der ive here for (4.3) are not
usually the ones produced when this recursion is given exactly s1 + 1 1s as the initial condi-
tions (indeed, it is not necessarily true that any solution e xists when the initial conditions
are precisely s1 + 1 1s). 2 The intuition for this is as follows: any binary tree-based s olution
R(n) for (4.3) has the property that periodically it will have in crements of 1 for a stretch
of 2 j indices, corresponding to that portion of the tree where we s uccessively count the
2j consecutive leaf labels in the pair of leaves of the tree. But such a regularity to the
increments in the solution is not usually present when the in itial conditions for (4.3) are
exactly s1 + 1 1s.
We now prove a necessary condition for a solution A(n) of (1.1) to be the leaf label
counting function for some tree K as constructed in Section 2. Any such A(n) has the
property that A(n + 1)−A(n) ∈ { 0, 1}. Therefore the sequence A is completely determined
by its frequency sequence F deﬁned by F (m) = |A−1({m})|. We show that F reﬂects
the self-similarity of K, in the sense that we can partition F into blocks such that each
block can be obtained from the previous block by a suitable tr ansformation.
To see this, assume for simplicity that K contains one label in each regular node. Consider
all values A(n) as n ranges over the labels in the subtree Ki. Deﬁne the frequency sequence
Fi for that segment of A by Fi(m) = |A−1({m}) ∩ { n : n ∈ K i}|. We only consider the
non-zero values of Fi so Fi is a ﬁnite sequence. For i ≥ p, recall that Ki+1 is obtained
from Ki by adding k children to each leaf of Ki. It follows from this that for i ≥ p, Fi+1
is obtained from Fi as follows: ﬁrst increase every value of Fi by 1 except its last value
(which is a 1 corresponding to the last leaf label of Ki); then insert k − 1 1s between each
successive pair of these values.
For 2 ≤ i < p , the derivation of Fi+1 from Fi follows the same general procedure.
However, in this range the number of children of each penulti mate node in Ki+1 is not
necessarily k, so the number of 1s inserted between pairs of values is not ne cessarily k − 1.
Instead it is determined by the ﬁnite tree T that is used to construct K. Finally, F2 and
F1 are determined directly from their deﬁnitions.
The partition of F we seek is not given by the Fi but by the sequences F ∗
i that are
determined by removing the last value in each Fi and for i ≥ 2, increasing the ﬁrst value of
Fi by 1. In this way they correct the frequency of A(N(i)). Here’s why: the last value in Fi,
which is a 1, results from the sole occurrence of A(N(i)) in the sequence {A(n); n ∈ K i}.
However, from the construction of K, F (A(N(i)) = 1 + Fi+1(A(N(i))) = F ∗
i+1(A(N(i))).
The sequence F is the inﬁnite word resulting from the concatenation of all t he F ∗
i , that is,
F = ∏ ∞
i=1 F ∗
i .
2It is shown in Theorem 6.4 of [7] that the recursion (4.3), tog ether with exactly s1 + 1 1s as the
initial conditions, where s1 + 1 ≥ s + 2j, has a well-deﬁned solution, although no tree-based combin atorial
interpretation for it could be identiﬁed.
SOL VING NON-HOMOGENEOUS NESTED RECURSIONS USING TREES 13
We illustrate the above discussion using Conolly’s origina l recursion
C(n) = C(n − C(n − 1)) + C(n − 1 − C(n − 2)); C(1) = 1 , C (2) = 2 .
C(n) counts the number of leaf labels in the binary tree of Figure 4.1 with one label per
regular node and no labels in the supernodes. The frequency s equence is F (m) = ν2(2m)
where ν2(m) is the 2-adic valuation of m. We can decompose F as F ∗
1 = 1, F ∗
2 = 2 , 1,
F ∗
3 = 3 , 1, 2, 1 . . . It is precisely the decomposability of the frequency sequen ce as above
that allows one to interpret solutions to recursions of the f orm (1.1) as counting leaves in
some inﬁnite tree. While it is straightforward to decompose the frequency sequence of C(n)
(the beginning of F ∗
i is the ﬁrst occurrence of i), we do not have a criterion to determine
decomposability of general meta-Fibonacci sequences aris ing as solutions to (1.1). The
problem of determining whether any tree T , and hence K, corresponds to a given frequency
sequence appears challenging.
Our ﬁnal observation is that when the initial conditions are speciﬁed by a tree K we may
change the ﬁrst few initial conditions arbitrarily without aﬀecting the resulting solution
sequence. Notice that if n > N (p + 1), pruning the tree K(n − ij) for 1 ≤ i ≤ j results in
a tree containing the ﬁrst p subtrees K1 to Kp. Suppose that for 1 ≤ n ≤ N(p) − 1 we set
R(n) arbitrarily, and for N(p) ≤ n ≤ N(p + 1) we leave R(n) as the number of leaf labels
in K(n). Then the recurrence relations (1.3) or (4.1) will be satis ﬁed by R(n) with the new
initial conditions, because the pruned trees PK(n − ij) for n > N (p + 1) and 1 ≤ i ≤ k will
contain the ﬁrst N(p) labels. As such, all the arguments of the recursion will hav e value at
least N(p) and the proof proceeds as before. Thus, the ﬁrst N(p)−1 values of the sequence
R(n) can be set arbitrarily and the recurrence relations (1.3) o r (4.1) still holds.
We conclude by deriving the solution for the Golomb recursio n g(n) [5] discussed in
Section 1 using our tree-grafting methodology.
Example 3 (Golomb’s triangular sequence) . Golomb’s sequence is deﬁned by
g(n) = g(n − g(n − 1)) + 1 and g(1) = 1 .
Let T be be a rooted path of length 2. Take s0 = 1, sm = 0 for all m ≥ 1, and j = 1. Then
we construct the unary tree whose leaf counts generate Golom b’s sequence (see Figure 4.2).
This shows that Golomb’s sequence is a step function that inc reases by one at the indices
n =
( k+1
2
)
+ 1 for every k ≥ 1.3
1
3
4
5
6
7
8
9
10 
11 2
Figure 4.2. The unary tree K that generates Golomb’s recursive sequence.
3The step function property implies that g(n) has a closed form, namely, g(n) = ⌊ ⌊
√
8n⌋+1
2 ⌋. See [5].
14 ABRAHAM ISGUR, MUSTAZEE RAHMAN, AND STEPHEN TANNY
References
[1] B. Balamohan, A. Kuznetsov and S. Tanny, On the behaviour of a variant of Hofstadters Q-sequence,
J. Integer Seq. 10 (2007), Article 07.7.1.
[2] B. Balamohan, Z. Li, and S. Tanny, A combinatorial interp retation for certain relatives of the Conolly
sequence, J. Integer Seq. 11 (2008), Article 08.2.1.
[3] J. Callaghan, J. J. Chew III, and S. Tanny, On the Behavior of a Family of Meta-Fibonacci Sequences,
SIAM J. Discrete Math. 18(4) (2005), 794–824.
[4] B.W. Conolly, Fibonacci and meta-Fibonacci sequences. in: S. Vajda. ed., Fibonacci & Lucas Numbers
and the Golden Section: Theory and Applications , E. Horwood Ltd., Chichester, 1989, 127–139.
[5] S. Golomb, Discrete chaos: sequences satisfying “stran ge” recursions, preprint (undated, probably late
eighties or early nineties).
[6] D. R. Hofstadter, G¨ odel, Escher, Bach: An Eternal Golden Braid , Random House, 1979.
[7] A. Isgur, D. Reiss, and S. Tanny, Trees and meta-Fibonacc i sequences, Elecron. J. Combin. 16(1)
(2009), R129.
[8] B. Jackson and F. Ruskey, Meta-Fibonacci sequences, bin ary trees and extremal compact codes, Elec-
tron. J. Combin. 13 (2006), R26.
[9] F. Ruskey and C. Deugau, The combinatorics of certain k-ary meta-Fibonacci sequences, J. Integer
Seq. 12 (2009), Article 09.4.3.
[10] S.M. Tanny, A well-behaved cousin of the Hofstadter seq uence, Discrete Math. 105 (1992), 227–239.
Department of Mathematics, University of Toronto, 40 St. George Street, Toronto, ON
M5S 2E4, Canada
E-mail address , Abraham Isgur: umarovi@gmail.com
E-mail address , Mustazee Rahman: mustazee.rahman@utoronto.ca
E-mail address , Steve Tanny: tanny@math.utoronto.ca